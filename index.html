
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Keep It Simple, Stupid</title>
  <meta name="author" content="samung">

  
  <meta name="description" content="我厂主要系统采用模块化开发以来，就遇到诸多的问题，不过都还可以解决。模块化我们选用了karaf这个集成组件。 开发中遇到数据源的配置问题。主要表现在每一位开发的数据库都是分开的，线上产品的数据库也是分开，线上数据库通过CMDB工具可以取到相应配置。 要解决以上需求， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yangtao309.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Keep It Simple, Stupid" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Keep It Simple, Stupid</a></h1>
  
    <h2>简单 快乐 追求</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yangtao309.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories">Categories</a></li>
  <li><a href="/blog/about">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/18/karaf-ying-yong-zhong-ru-he-pei-zhi-shu-ju-yuan/">Karaf 应用中如何配置数据源</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-18T18:52:54+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/08/18/karaf-ying-yong-zhong-ru-he-pei-zhi-shu-ju-yuan/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我厂主要系统采用模块化开发以来，就遇到诸多的问题，不过都还可以解决。模块化我们选用了<strong>karaf</strong>这个集成组件。</p>

<p>开发中遇到数据源的配置问题。主要表现在每一位开发的数据库都是分开的，线上产品的数据库也是分开，线上数据库通过<strong>CMDB</strong>工具可以取到相应配置。</p>

<p>要解决以上需求，我们将开发和线上的datasource分成了两个独立的模块，开发对应模块xx-datasource-dev,那么线上对应的就是xx-datasource-production. 为什么要分成两个项目？ 很明显，我们开发环境中没有<strong>CMDB</strong>这样工具来集中管理开发人员的数据库，目前还是开发自己在玩自己的数据库。</p>

<p>这样我们的开发数据库基本上依赖maven来构建。</p>

<p>线上的依赖<strong>CMDB</strong>在初始化客户系统的时候，创建好数据源。看起来一切很ok,但是没法重启。(因为部署的时候消息触发来取<strong>CMDB</strong>的配置信息, 重启只是重启整个<strong>karaf</strong>)</p>

<p>我们考虑到了，需要将线上初始化取到的<strong>CMBD</strong>配置进行持久化(写文件)。 那么在<strong>karaf</strong>环境下如何写文件和读文件呢？</p>

<p>我们参考了<strong>karaf</strong><a href="http://karaf.apache.org/manual/latest/users-guide/configuration.html">官方手册</a>的介绍。</p>

<h3>实例</h3>

<p>首先需要写一个POJO来处理datasource的基础属性，我们这里简单处理只设置driver | url | username | password 4个属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class Datasource {
</span><span class='line'>    public final static String DATASOURCE_PROP_PID = "datasource.prop";
</span><span class='line'>
</span><span class='line'>    private String driver;
</span><span class='line'>    private String url;
</span><span class='line'>    private String username;
</span><span class='line'>    private String password;
</span><span class='line'>
</span><span class='line'>    public String getDriver() {
</span><span class='line'>        return driver;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setDriver(String driver) {
</span><span class='line'>        this.driver = driver;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getPassword() {
</span><span class='line'>        return password;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setPassword(String password) {
</span><span class='line'>        this.password = password;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getUrl() {
</span><span class='line'>        return url;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setUrl(String url) {
</span><span class='line'>        this.url = url;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public String getUsername() {
</span><span class='line'>        return username;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setUsername(String username) {
</span><span class='line'>        this.username = username;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>定义一个读配置的service，可以在datasource bundle激活器被触发时候来设置数据源并进行服务注册。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface DatasourceQuery {
</span><span class='line'>    Datasource findDatabase();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public class DatasourceQueryImpl implements DatasourceQuery {
</span><span class='line'>    @Override
</span><span class='line'>    public Datasource findDatabase() {
</span><span class='line'>        return datasource;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private Datasource datasource;
</span><span class='line'>
</span><span class='line'>    public Datasource getDatasource() {
</span><span class='line'>        return datasource;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void setDatasource(Datasource datasource) {
</span><span class='line'>        this.datasource = datasource;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>程序很简单，关键是配置，目前karaf默认配置应用的是<strong>blueprint</strong>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>文件目录地址: src/main/resources/OSGI-INF/blueprint/database.xml
</span><span class='line'>
</span><span class='line'>&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
</span><span class='line'>           xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0"
</span><span class='line'>           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:osgi="http://www.osgi.org/xmlns/blueprint/v1.0.0"
</span><span class='line'>           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0
</span><span class='line'>                http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
</span><span class='line'>                http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0
</span><span class='line'>                http://aries.apache.org/schemas/blueprint-cm/blueprint-cm-1.1.0.xsd"&gt;
</span><span class='line'>    &lt;cm:property-placeholder persistent-id="datasource.prop" update-strategy="reload"&gt;
</span><span class='line'>        &lt;cm:default-properties&gt;
</span><span class='line'>            &lt;cm:property name="driver" value=""/&gt;
</span><span class='line'>            &lt;cm:property name="url" value=""/&gt;
</span><span class='line'>            &lt;cm:property name="username" value=""/&gt;
</span><span class='line'>            &lt;cm:property name="password" value=""/&gt;
</span><span class='line'>        &lt;/cm:default-properties&gt;
</span><span class='line'>    &lt;/cm:property-placeholder&gt;
</span><span class='line'>
</span><span class='line'>    &lt;bean id="datasource" class="com.xx.Datasource"&gt;
</span><span class='line'>        &lt;property name="driver" value="${driver}"/&gt;
</span><span class='line'>        &lt;property name="url" value="${url}"/&gt;
</span><span class='line'>        &lt;property name="username" value="${username}"/&gt;
</span><span class='line'>        &lt;property name="password" value="${password}"/&gt;
</span><span class='line'>    &lt;/bean&gt;
</span><span class='line'>
</span><span class='line'>    &lt;bean id="datasourceQuery" class="com.xx.impl.DatasourceQueryImpl"&gt;
</span><span class='line'>        &lt;property name="datasource" ref="datasource"/&gt;
</span><span class='line'>    &lt;/bean&gt;
</span><span class='line'>
</span><span class='line'>    &lt;service ref="datasourceQuery" interface="com.xx.DatasourceDevPropQuery"/&gt;
</span><span class='line'>&lt;/blueprint&gt;</span></code></pre></td></tr></table></div></figure>


<p>以上配置是比较关键的。在整个bundle加载的时候会将<strong>karaf</strong>的/etc/datasource.prop.cfg文件对应起来，并可以通过config命令进行写入值，也可以读取值。</p>

<p>对于在发布该bundle的时候，需要将对应的文件也写入到指定的文件目录:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;feature name="database" version="${project.version}"&gt;
</span><span class='line'>        &lt;configfile finalname="/etc/datasource.prop.cfg"&gt;mvn:com.xx/datasource-prop/${version}/cfg/datasource.prop&lt;/configfile&gt;
</span><span class='line'>        &lt;feature version="${version}"&gt;datasource-prop&lt;/feature&gt;
</span><span class='line'>    &lt;/feature&gt;</span></code></pre></td></tr></table></div></figure>


<p>另外要考虑的如何才能符合上述的格式进行安装(configfile).</p>

<p>需要在编译安装的时候进行生成，在<strong>pom.xml</strong>需要用到插件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;plugin&gt;
</span><span class='line'>                &lt;inherited&gt;false&lt;/inherited&gt;
</span><span class='line'>                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
</span><span class='line'>                &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
</span><span class='line'>                &lt;version&gt;1.8&lt;/version&gt;
</span><span class='line'>                &lt;executions&gt;
</span><span class='line'>                    &lt;execution&gt;
</span><span class='line'>                        &lt;id&gt;attach-artifacts&lt;/id&gt;
</span><span class='line'>                        &lt;phase&gt;package&lt;/phase&gt;
</span><span class='line'>                        &lt;goals&gt;
</span><span class='line'>                            &lt;goal&gt;attach-artifact&lt;/goal&gt;
</span><span class='line'>                        &lt;/goals&gt;
</span><span class='line'>                        &lt;configuration&gt;
</span><span class='line'>                            &lt;artifacts&gt;
</span><span class='line'>                                &lt;artifact&gt;
</span><span class='line'>                                    &lt;file&gt;target/classes/datasource.prop.cfg&lt;/file&gt;
</span><span class='line'>                                    &lt;type&gt;cfg&lt;/type&gt;
</span><span class='line'>                                    &lt;classifier&gt;datasource.prop&lt;/classifier&gt;
</span><span class='line'>                                &lt;/artifact&gt;
</span><span class='line'>                            &lt;/artifacts&gt;
</span><span class='line'>                        &lt;/configuration&gt;
</span><span class='line'>                    &lt;/execution&gt;
</span><span class='line'>                &lt;/executions&gt;
</span><span class='line'>            &lt;/plugin&gt;</span></code></pre></td></tr></table></div></figure>


<p>这样写好后，只需要在<strong>karaf</strong>里面安装该bundle，然后去指定文件目录确定该文件是否生成。生成后，就可以用<strong>karaf</strong>提供的config命令来进行设置值了。</p>

<p>在后续的datasource bundle的激活器中进行存储和获取。</p>

<p>具体代码会整理一个github小项目供大家下载。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/17/understanding-java-garbage-collection/">Understanding Java Garbage Collection</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-17T20:33:09+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/08/17/understanding-java-garbage-collection/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cubrid.org/blog/dev-platform/understanding-java-garbage-collection/">原文</a></p>

<p>What are the benefits of knowing how garbage collection (GC) works in Java? Satisfying the intellectual curiosity as a software engineer would be a valid cause, but also, understanding how GC works can help you write much better Java applications.</p>

<p>This is a very personal and subjective opinion of mine, but I believe that a person well versed in GC tends to be a better Java developer. If you are interested in the GC process, that means you have experience in developing applications of certain size. If you have thought carefully about choosing the right GC algorithm, that means you completely understand the features of the application you have developed. Of course, this may not be common standards for a good developer. However, few would object when I say that understanding GC is a requirement for being a great Java developer.</p>

<p>This is the first of a series of &ldquo;Become a Java GC Expert&rdquo; articles. I will cover the GC introduction this time, and in the next article, I will talk about analyzing GC status and GC tuning examples from NHN.</p>

<p>The purpose of this article is to introduce GC to you in an easy way. I hope this article proves to be very helpful. Actually, my colleagues have already published a few great articles on Java Internals which became quite popular on Twitter. You may refer to them as well.</p>

<p>Returning back to Garbage Collection, there is a term that you should know before learning about GC. The term is &ldquo;stop-the-world.&rdquo; Stop-the-world will occur no matter which GC algorithm you choose. Stop-the-world means that the JVM is stopping the application from running to execute a GC. When stop-the-world occurs, every thread except for the threads needed for the GC will stop their tasks. The interrupted tasks will resume only after the GC task has completed. GC tuning often means reducing this stop-the-world time.</p>

<h3>Generational Garbage Collection</h3>

<p>Java does not explicitly specify a memory and remove it in the program code. Some people sets the relevant object to null or use System.gc() method to remove the memory explicitly. Setting it to null is not a big deal, but calling System.gc() method will affect the system performance drastically, and must not be carried out. (Thankfully, I have not yet seen any developer in NHN calling this method.)</p>

<p>In Java, as the developer does not explicitly remove the memory in the program code, the garbage collector finds the unnecessary (garbage) objects and removes them. This garbage collector was created based on the following two hypotheses. (It is more correct to call them suppositions or preconditions, rather than hypotheses.)</p>

<ul>
<li>Most objects soon become unreachable.</li>
<li>References from old objects to young objects only exist in small numbers.</li>
</ul>


<p>These hypotheses are called the weak generational hypothesis. So in order to preserve the strengths of this hypothesis, it is physically divided into two - young generation and old generation - in HotSpot VM.</p>

<p>Young generation: Most of the newly created objects are located here. Since most objects soon become unreachable, many objects are created in the young generation, then disappear. When objects disappear from this area, we say a &ldquo;minor GC&rdquo; has occurred.</p>

<p>Old generation: The objects that did not become unreachable and survived from the young generation are copied here. It is generally larger than the young generation. As it is bigger in size, the GC occurs less frequently than in the young generation. When objects disappear from the old generation, we say a &ldquo;major GC&rdquo; (or a &ldquo;full GC&rdquo;) has occurred.</p>

<p>Let&rsquo;s look at this in a chart.</p>

<p><img src="/images/java-gc-area-data-flow.png" alt="Alt text" /></p>

<p>The permanent generation from the chart above is also called the &ldquo;method area,&rdquo; and it stores classes or interned character strings. So, this area is definitely not for objects that survived from the old generation to stay permanently. A GC may occur in this area. The GC that took place here is still counted as a major GC.</p>

<p>Some people may wonder:</p>

<blockquote><p>  What if an object in the old generation need to reference an object in the young generation?</p></blockquote>

<p>To handle these cases, there is something called the a &ldquo;card table&rdquo; in the old generation, which is a 512 byte chunk. Whenever an object in the old generation references an object in the young generation, it is recorded in this table. When a GC is executed for the young generation, only this card table is searched to determine whether or not it is subject for GC, instead of checking the reference of all the objects in the old generation. This card table is managed with write barrier. This write barrier is a device that allows a faster performance for minor GC. Though a bit of overhead occurs because of this, the overall GC time is reduced.</p>

<p><img src="/images/card-table-structure.png" alt="Alt text" /></p>

<h3>Composition of the Young Generation</h3>

<p>In order to understand GC, let&rsquo;s learn about the young generation, where the objects are created for the first time. The young generation is divided into 3 spaces.</p>

<ul>
<li>One Eden space</li>
<li>Two Survivor spaces</li>
</ul>


<p>There are 3 spaces in total, two of which are Survivor spaces. The order of execution process of each space is as below:</p>

<ol>
<li>The majority of newly created objects are located in the Eden space.</li>
<li>After one GC in the Eden space, the surviving objects are moved to one of the Survivor spaces.</li>
<li>After a GC in the Eden space, the objects are piled up into the Survivor space, where other surviving objects already exist.</li>
<li>Once a Survivor space is full, surviving objects are moved to the other Survivor space. Then, the Survivor space that is full will be changed to a state where there is no data at all.</li>
<li>The objects that survived these steps that have been repeated a number of times are moved to the old generation.</li>
</ol>


<p>As you can see by checking these steps, one of the Survivor spaces must remain empty. If data exists in both Survivor spaces, or the usage is 0 for both spaces, then take that as a sign that something is wrong with your system.</p>

<p>The process of data piling up into the old generation through minor GCs can be shown as in the below chart:</p>

<p><img src="/images/before-and-after-java-gc.png" alt="Alt text" /></p>

<p>Note that in HotSpot VM, two techniques are used for faster memory allocations. One is called &ldquo;bump-the-pointer,&rdquo; and the other is called &ldquo;TLABs (Thread-Local Allocation Buffers).&rdquo;</p>

<p>Bump-the-pointer technique tracks the last object allocated to the Eden space. That object will be located on top of the Eden space. And if there is an object created afterwards, it checks only if the size of the object is suitable for the Eden space. If the said object seems right, it will be placed in the Eden space, and the new object goes on top. So, when new objects are created, only the lastly added object needs to be checked, which allows much faster memory allocations. However, it is a different story if we consider a multithreaded environment. To save objects used by multiple threads in the Eden space for Thread-Safe, an inevitable lock will occur and the performance will drop due to the lock-contention. TLABs is the solution to this problem in HotSpot VM. This allows each thread to have a small portion of its Eden space that corresponds to its own share. As each thread can only access to their own TLAB, even the bump-the-pointer technique will allow memory allocations without a lock.</p>

<p>This has been a quick overview of the GC in the young generation. You do not necessarily have to remember the two techniques that I have just mentioned. You will not go to jail for not knowing them. But please remember that after the objects are first created in the Eden space, and the long-surviving objects are moved to the old generation through the Survivor space.</p>

<h3>GC for the Old Generation</h3>

<p>The old generation basically performs a GC when the data is full. The execution procedure varies by the GC type, so it would be easier to understand if you know different types of GC.</p>

<p>According to JDK 7, there are 5 GC types.</p>

<ol>
<li>Serial GC</li>
<li>Parallel GC</li>
<li>Parallel Old GC (Parallel Compacting GC)</li>
<li>Concurrent Mark &amp; Sweep GC  (or &ldquo;CMS&rdquo;)</li>
<li>Garbage First (G1) GC</li>
</ol>


<p>Among these, the serial GC must not be used on an operating server. This GC type was created when there was only one CPU core on desktop computers. Using this serial GC will drop the application performance significantly.</p>

<p>Now let&rsquo;s learn about each GC type.</p>

<h4>Serial GC (-XX:+UseSerialGC)</h4>

<p>The GC in the young generation uses the type we explained in the previous paragraph. The GC in the old generation uses an algorithm called &ldquo;mark-sweep-compact.&rdquo;</p>

<ol>
<li>The first step of this algorithm is to mark the surviving objects in the old generation.</li>
<li>Then, it checks the heap from the front and leaves only the surviving ones behind (sweep).</li>
<li>In the last step, it fills up the heap from the front with the objects so that the objects are piled up consecutively, and divides the heap into two parts: one with objects and one without objects (compact).</li>
</ol>


<p>The serial GC is suitable for a small memory and a small number of CPU cores.</p>

<h4>Parallel GC (-XX:+UseParallelGC)</h4>

<p><img src="/images/difference-between-the-serial-gc-and-parallel-gc.png" alt="Alt text" /></p>

<p>From the picture, you can easily see the difference between the serial GC and parallel GC. While the serial GC uses only one thread to process a GC, the parallel GC uses several threads to process a GC, and therefore, faster. This GC is useful when there is enough memory and a large number of cores. It is also called the &ldquo;throughput GC.&rdquo;</p>

<h4>Parallel Old GC(-XX:+UseParallelOldGC)</h4>

<p>Parallel Old GC was supported since JDK 5 update. Compared to the parallel GC, the only difference is the GC algorithm for the old generation. It goes through three steps: mark – summary – compaction. The summary step identifies the surviving objects separately for the areas that the GC have previously performed, and thus different from the sweep step of the mark-sweep-compact algorithm. It goes through a little more complicated steps.</p>

<h4>CMS GC (-XX:+UseConcMarkSweepGC)</h4>

<p><img src="/images/serial-gc-and-cms-gc.png" alt="Alt text" /></p>

<p>As you can see from the picture, the Concurrent Mark-Sweep GC is much more complicated than any other GC types that I have explained so far. The early initial mark step is simple. The surviving objects among the objects the closest to the classloader are searched. So, the pausing time is very short. In the concurrent mark step, the objects referenced by the surviving objects that have just been confirmed are tracked and checked. The difference of this step is that it proceeds while other threads are processed at the same time. In the remark step, the objects that were newly added or stopped being referenced in the concurrent mark step are checked. Lastly, in the concurrent sweep step, the garbage collection procedure takes place. The garbage collection is carried out while other threads are still being processed. Since this GC type is performed in this manner, the pausing time for GC is very short. The CMS GC is also called the low latency GC, and is used when the response time from all applications is crucial.</p>

<p>While this GC type has the advantage of short stop-the-world time, it also has the following disadvantages.</p>

<ol>
<li>It uses more memory and CPU than other GC types.</li>
<li>The compaction step is not provided by default.</li>
</ol>


<p>You need to carefully review before using this type. Also, if the compaction task needs to be carried out because of the many memory fragments, the stop-the-world time can be longer than any other GC types. You need to check how often and how long the compaction task is carried out.</p>

<h4>G1 GC</h4>

<p>Finally, let&rsquo;s learn about the garbage first (G1) GC.</p>

<p><img src="/images/layout-of-g1-gc.png" alt="Alt text" /></p>

<p>If you want to understand G1 GC, forget everything you know about the young generation and the old generation. As you can see in the picture, one object is allocated to each grid, and then a GC is executed. Then, once one area is full, the objects are allocated to another area, and then a GC is executed. The steps where the data moves from the three spaces of the young generation to the old generation cannot be found in this GC type. This type was created to replace the CMS GC, which has causes a lot of issues and complaints in the long term.</p>

<p>The biggest advantage of the G1 GC is its performance. It is faster than any other GC types that we have discussed so far. But in JDK 6, this is called an early access and can be used only for a test. It is officially included in JDK 7. In my personal opinion, we need to go through a long test period (at least 1 year) before NHN can use JDK7 in actual services, so you probably should wait a while. Also, I heard a few times that a JVM crash occurred after applying the G1 in JDK 6. Please wait until it is more stable.</p>

<p>I will talk about the GC tuning in the next issue, but I would like to ask you one thing in advance. If the size and the type of all objects created in the application are identical, all the GC options for WAS used in our company can be the same. But the size and the lifespan of the objects created by WAS vary depending on the service, and the type of equipment varies as well. In other words, just because a certain service uses the GC option &ldquo;A,&rdquo; it does not mean that the same option will bring the best results for a different service. It is necessary to find the best values for the WAS threads, WAS instances for each equipment and each GC option by constant tuning and monitoring. This did not come from my personal experience, but from the discussion of the engineers making Oracle JVM for JavaOne 2010.</p>

<p>In this issue, we have only glanced at the GC for Java. Please look forward to our next issue, where I will talk about how to monitor the Java GC status and tune GC.</p>

<p>I would like to note that I referred to a new book released in December 2011 called &ldquo;Java Performance&rdquo; (Amazon, it can also be viewed from safari online, if the company provides an account), as well as “Memory Management in the Java HotSpotTM Virtual Machine,” a white paper provided by the Oracle website. (The book is different from &ldquo;Java Performance Tuning.&rdquo;)</p>

<p>By Sangmin Lee, Senior Engineer at Performance Engineering Lab, NHN Corporation.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/17/how-to-analyze-java-thread-dumps/">How to Analyze Java Thread Dumps</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-17T17:18:05+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/08/17/how-to-analyze-java-thread-dumps/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The content of this article was originally written by Tae Jin Gu on the <a href="http://www.cubrid.org/blog/dev-platform/how-to-analyze-java-thread-dumps/">Cubrid blog</a>.</p>

<p>该文来源于Cubrid blog(不过源地址已没有相关内容，本文翻译系转载)</p>

<p>When there is an obstacle, or when a Java based Web application is running much slower than expected, we need to use <strong>thread dumps</strong>. If <strong>thread dumps</strong> feel like very complicated to you, this article may help you very much. Here I will explain what threads are in Java, their types, how they are created, how to manage them, how you can dump threads from a running application, and finally how you can analyze them and determine the bottleneck or blocking threads. This article is a result of long experience in Java application debugging.</p>

<p>当Java程序遇到了麻烦,或者Java编写的Web应用运行得比预期情况慢,就可以使用<strong>thread dumps</strong>这一利器分析问题.如果你觉得<strong>thread dumps</strong>很复杂,那么阅读本文会对你有所帮助.本文将介绍什么是Java线程,线程的种类,如何创建,如何管理,如何对正在运行的程序进行<strong>thread dumps</strong>,如何分析,最终找到瓶颈或阻塞线程.本文总结了长期调试Java程序的经验.</p>

<h2>Java and Thread</h2>

<h2>java和线程</h2>

<p>A web server uses tens to hundreds of threads to process a large number of concurrent users. If two or more threads utilize the same resources, a contention between the threads is inevitable, and sometimes deadlock occurs.</p>

<p>Web服务器通常创建很多线程去处理高并发的用户请求.如果两三个线程使用同样的服务器资源,线程间的竞争就不可避免了,更糟糕的情况下还会发生死锁.</p>

<p><strong>Thread contention</strong> is a status in which one thread is waiting for a lock, held by another thread, to be lifted. Different threads frequently access shared resources on a web application. For example, to record a log, the thread trying to record the log must obtain a lock and access the shared resources.</p>

<p><strong>线程竞争</strong>是指一个线程等待另一个线程持有的锁.Web服务的不同线程会频繁地访问共享资源,比如记录日志:一个试图记录日志的线程必须先获得锁才能访问共享资源.</p>

<p><strong>Deadlock</strong> is a special type of thread contention, in which two or more threads are waiting for the other threads to complete their tasks in order to complete their own tasks.</p>

<p><strong>死锁</strong>是线程竞争的一个特殊形式.多个线程都在等待其它线程先于自己完成任务,于是陷入无尽的等待.</p>

<p>Different issues can arise from <strong>thread contention</strong>. To analyze such issues, you need to use the <strong>thread dump</strong>. A thread dump will give you the information on the exact status of each thread.</p>

<p><strong>线程竞争</strong>会导致很多问题,我们需要使用<strong>thread dumps</strong>来解决,它会提供每个线程状态的确切信息.</p>

<h2>Background Information for Java Threads</h2>

<h2>Java线程的背景知识</h2>

<h3>Thread Synchronization</h3>

<h3>线程同步</h3>

<p>A thread can be processed with other threads at the same time. In order to ensure compatibility when multiple threads are trying to use shared resources, one thread at a time should be allowed to access the shared resources by using <strong>thread synchronization</strong>.</p>

<p>多个线程可以同时运行,为了让使用共享资源的多个线程可以和平共处,同一时刻只允许一个线程访问共享资源,这是通过<strong>线程同步</strong>来实现的.</p>

<p><strong>Thread synchronization</strong> on Java can be done using monitor. Every Java object has a single monitor. The monitor can be owned by only one thread. For a thread to own a monitor that is owned by a different thread, it needs to wait in the wait queue until the other thread releases its monitor.</p>

<p>Java<strong>线程同步</strong>使用了<a href="http://zh.wikipedia.org/zh-cn/%E7%9B%A3%E8%A6%96%E5%99%A8_%28%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96%29">管程</a>.每个Java对象都有一个管程.每个管程只能被一个线程持有.如果一个线程想持有另一个线程持有的管程,它需要排队等待另一个线程去释放锁.</p>

<h3>Thread Status</h3>

<h3>线程的状态</h3>

<p>In order to analyze a <strong>thread dump</strong>, you need to know the status of threads. The statuses of threads are stated on java.lang.Thread.State.</p>

<p>为了分析<strong>thread dump</strong>,我们需要知道线程的状态,这些状态用java.lang.Thread.State来表示:</p>

<p><img src="/images/u404847178_13c476c51ffg85_blog.png" alt="Alt text" /></p>

<p> Figure 1: Thread Status.</p>

<ul>
<li>NEW: The thread is created but has not been processed yet.</li>
<li>RUNNABLE: The thread is occupying the CPU and processing a task. (It may be in WAITING status due to the OS&rsquo;s resource distribution.)</li>
<li>BLOCKED: The thread is waiting for a different thread to release its lock in order to get the monitor lock.</li>
<li>WAITING: The thread is waiting by using a wait, join or park method.</li>
<li><p>TIMED_WAITING: The thread is waiting by using a sleep, wait, join or park method. (The difference from WAITING is that the maximum waiting time is specified by the method parameter, andWAITING can be relieved by time as well as external changes.)</p></li>
<li><p>NEW: 线程已经被建立,但是还没有执行.</p></li>
<li>RUNNABLE: 线程正使用CPU来处理任务(因为操作系统的资源调度原因,线程可以处于WAITING状态)</li>
<li>BLOCKED: 线程正在等待另一个线程释放锁.</li>
<li>WAITING: 线程因为使用了wait, join 或 park 方法而处于等待状态.</li>
<li>TIMED_WAITING: 线程因为使用了sleep, wait, join 或 park 方法而处于等待状态. (和 WAITING 状态的区别是, 除了外部条件改变之外, 此状态有超时机制, 过了给定的最长等待时间, 此等待状态就解除了)</li>
</ul>


<h3>Thread Types</h3>

<h3>线程种类</h3>

<p>Java threads can be divided into two:</p>

<ol>
<li> daemon threads;</li>
<li> and non-daemon threads.</li>
</ol>


<p>Java的线程可分为两类:</p>

<ol>
<li> 监控线程</li>
<li> 非监控线程</li>
</ol>


<p>Daemon threads stop working when there are no other non-daemon threads. Even if you do not create any threads, the Java application will create several threads by default. Most of them are daemon threads, mainly for processing tasks such as garbage collection or JMX.</p>

<p>当没有其它非监控线程继续运行时,监控线程才会停止.即使你没有创建任何线程,Java程序也会创建几个默认线程.默认线程大多是监控线程,主要是为了垃圾回收或者JMX.</p>

<p>A thread running the &lsquo;static void main(String[] args)’ method is created as a non-daemon thread, and when this thread stops working, all other daemon threads will stop as well. (The thread running this main method is called the VM thread in HotSpot VM.)</p>

<p>Java线程同步使用了管程.每个Java对象都有一个管程.每个管程只能被一个线程持有.如果一个线程想持有另一个线程持有的管程,它需要在排队等待另一个线程去释放.执行main方法的线程时非监控线程,当它结束时,所有的监控线程也都要停止.(在HotSpot VM里,这个线程叫做VM Thread).</p>

<h3>Getting a Thread Dump</h3>

<h3>获取Thread Dump</h3>

<p>We will introduce the three most commonly used methods. Note that there are many other ways to get a thread dump. A thread dump can only show the thread status at the time of measurement, so in order to see the change in thread status, it is recommended to extract them from 5 to 10 times with 5-second intervals.</p>

<p>有很多种方法可以得到<strong>thread dump</strong>,我们将介绍最常见的三种方法.一个<strong>thread dump</strong>只能包含转储时刻的线程状态,所以为了分析线程状态的变化,最好每隔5秒获取一次,得到5~10个<strong>thread dump</strong>就可以了.</p>

<h4>Getting a Thread Dump Using jstack</h4>

<h4>使用jstack</h4>

<p>In JDK 1.6 and higher, it is possible to get a thread dump on MS Windows using jstack.</p>

<p>Use PID via jps to check the PID of the currently running Java application process.</p>

<p>如果JDK版本是1.6或以上,可以在MS Windows上使用jstack.</p>

<p>使用jps来产看系统上正运行的java进程的PID.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ jps -v
</span><span class='line'>25780 RemoteTestRunner -Dfile.encoding=UTF-8
</span><span class='line'>25590 sub.rmi.registry.RegistryImpl 2999 -Dapplication.home=/home1/user/java/jdk.1.6.0_24 -Xms8m
</span><span class='line'>26300 sun.tools.jps.Jps -mlvV -Dapplication.home=/home1/user/java/jdk.1.6.0_24 -Xms8m</span></code></pre></td></tr></table></div></figure>


<p>Use the extracted PID as the parameter of jstack to obtain a thread dump.</p>

<p>把pid作为参数传给jstack,以获取该pid对应java进程的线程转储.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ jstack -f 5824</span></code></pre></td></tr></table></div></figure>


<h4>A Thread Dump Using jVisualVM</h4>

<h4>使用jVisualVM</h4>

<p>Generate a thread dump by using a program such as jVisualVM.</p>

<p>jVisualVM是JDK提供的可视化工具.</p>

<p><img src="/images/u404847178_13c476d1fd4g86_blog.png" alt="Alt text" /></p>

<p>Figure 2:  A Thread Dump Using visualvm.</p>

<p>The task on the left indicates the list of currently running processes. Click on the process for which you want the information, and select the thread tab to check the thread information in real time. Click the Thread Dump button on the top right corner to get the thread dump file.</p>

<p>左侧列举了正在运行的java进程.单击想要分析的进程,选择thread选项卡,可以看到实时信息.单击右上角的Thread Dump按钮生成线程转储文件.</p>

<h4>Generating in a Linux Terminal</h4>

<p>Obtain the process pid by using ps -ef command to check the pid of the currently running Java process.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ ps - ef | grep java
</span><span class='line'>user      2477          1    0 Dec23 ?         00:10:45 ...
</span><span class='line'>user    25780 25361   0 15:02 pts/3    00:00:02 ./jstatd -J -Djava.security.policy=jstatd.all.policy -p 2999
</span><span class='line'>user    26335 25361   0 15:49 pts/3    00:00:00 grep java</span></code></pre></td></tr></table></div></figure>


<p>Use the extracted pid as the parameter of kill –SIGQUIT(3) to obtain a thread dump.</p>

<h4>Thread Information from the Thread Dump File</h4>

<h4>线程转储文件包含的线程信息</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"pool-1-thread-13" prio=6 tid=0x000000000729a000 nid=0x2fb4 runnable [0x0000000007f0f000] java.lang.Thread.State: RUNNABLE
</span><span class='line'>at java.net.SocketInputStream.socketRead0(Native Method)
</span><span class='line'>at java.net.SocketInputStream.read(SocketInputStream.java:129)
</span><span class='line'>at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)
</span><span class='line'>at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)
</span><span class='line'>at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)
</span><span class='line'> 
</span><span class='line'>- locked &lt;0x0000000780b7e688&gt; (a java.io.InputStreamReader)
</span><span class='line'> 
</span><span class='line'>at java.io.InputStreamReader.read(InputStreamReader.java:167)
</span><span class='line'>at java.io.BufferedReader.fill(BufferedReader.java:136)
</span><span class='line'>at java.io.BufferedReader.readLine(BufferedReader.java:299)
</span><span class='line'> 
</span><span class='line'>- locked &lt;0x0000000780b7e688&gt; (a java.io.InputStreamReader)
</span><span class='line'> 
</span><span class='line'>at java.io.BufferedReader.readLine(BufferedReader.java:362)
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Thread name: When using Java.lang.Thread class to generate a thread, the thread will be named Thread-(Number), whereas when using java.util.concurrent.ThreadFactory class, it will be named pool-(number)-thread-(number).</li>
<li>Priority: Represents the priority of the threads.</li>
<li>Thread ID: Represents the unique ID for the threads. (Some useful information, including the CPU usage or memory usage of the thread, can be obtained by using thread ID.)</li>
<li>Thread status: Represents the status of the threads.</li>
<li><p>Thread callstack: Represents the call stack information of the threads.</p></li>
<li><p>Thread name 线程名: 使用 Java.lang.Thread类去创建线程时,线程的命名方式为Thread-(序号);当使用java.util.concurrent.ThreadFactory类去创建线程时,线程的命名方式为pool-(序号)-thread-(序号).</p></li>
<li>Priority 优先级: 表示线程的优先级.</li>
<li>Thread ID 线程ID: 线程的ID是唯一的(一些有用的信息,比如线程的CPU使用率或者内存使用率,可以通过线程ID找到).</li>
<li>Thread status 线程状态: 表示线程的状态.</li>
<li>Thread callstack 线程调用栈: 表示线程的调用栈信息.</li>
</ul>


<h3>Thread Dump Patterns by Type</h3>

<h3>线程转储的类型布局</h3>

<h4>When Unable to Obtain a Lock (BLOCKED)</h4>

<h4>无法获得锁的时候</h4>

<p>This is when the overall performance of the application slows down because a thread is occupying the lock and prevents other threads from obtaining it. In the following example, BLOCKED_TEST pool-1-thread-1 thread is running with <0x0000000780a000b0> lock, while BLOCKED_TEST pool-1-thread-2 and BLOCKED_TEST pool-1-thread-3 threads are waiting to obtain <0x0000000780a000b0> lock.</p>

<p>此时整个应用的性能下降了,因为一个线程持有了锁而不肯释放,导致其它线程无法获得锁.在下面的例子里,线程BLOCKED_TEST pool-1-thread-1 获得了锁<0x0000000780a000b0>并且正在运行,此时线程 BLOCKED_TEST pool-1-thread-2 和线程 BLOCKED_TEST pool-1-thread-3 在等待锁<0x0000000780a000b0>.</p>

<p><img src="/images/u404847178_13c476deae9g85_blog.png" alt="Alt text" /></p>

<p>Figure 3: A thread blocking other threads.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"BLOCKED_TEST pool-1-thread-1" prio=6 tid=0x0000000006904800 nid=0x28f4 runnable [0x000000000785f000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at java.io.FileOutputStream.writeBytes(Native Method)
</span><span class='line'>    at java.io.FileOutputStream.write(FileOutputStream.java:282)
</span><span class='line'>    at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)
</span><span class='line'>    at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:123)
</span><span class='line'>    - locked &lt;0x0000000780a31778&gt; (a java.io.BufferedOutputStream)
</span><span class='line'>    at java.io.PrintStream.write(PrintStream.java:432)
</span><span class='line'>    - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)
</span><span class='line'>    at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:202)
</span><span class='line'>    at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:272)
</span><span class='line'>    at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:85)
</span><span class='line'>    - locked &lt;0x0000000780a040c0&gt; (a java.io.OutputStreamWriter)
</span><span class='line'>    at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:168)
</span><span class='line'>    at java.io.PrintStream.newLine(PrintStream.java:496)
</span><span class='line'>    - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)
</span><span class='line'>    at java.io.PrintStream.println(PrintStream.java:687)
</span><span class='line'>    - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:44)
</span><span class='line'>    - locked &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState$1.run(ThreadBlockedState.java:7)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - &lt;0x0000000780a31758&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
</span><span class='line'>
</span><span class='line'>"BLOCKED_TEST pool-1-thread-2" prio=6 tid=0x0000000007673800 nid=0x260c waiting for monitor entry [0x0000000008abf000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:43)
</span><span class='line'>    - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState$2.run(ThreadBlockedState.java:26)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - &lt;0x0000000780b0c6a0&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
</span><span class='line'>
</span><span class='line'>"BLOCKED_TEST pool-1-thread-3" prio=6 tid=0x00000000074f5800 nid=0x1994 waiting for monitor entry [0x0000000008bbf000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:42)
</span><span class='line'>    - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState$3.run(ThreadBlockedState.java:34)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - &lt;0x0000000780b0e1b8&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span></code></pre></td></tr></table></div></figure>


<h4>When in Deadlock Status</h4>

<h4>死锁的时候</h4>

<p>This is when thread A needs to obtain thread B&rsquo;s lock to continue its task, while thread B needs to obtain thread A&rsquo;s lock to continue its task. In the thread dump, you can see that DEADLOCK_TEST-1 thread has 0x00000007d58f5e48 lock, and is trying to obtain 0x00000007d58f5e60 lock. You can also see that DEADLOCK_TEST-2 thread has 0x00000007d58f5e60 lock, and is trying to obtain 0x00000007d58f5e78 lock. Also, DEADLOCK_TEST-3 thread has 0x00000007d58f5e78 lock, and is trying to obtain 0x00000007d58f5e48 lock. As you can see, each thread is waiting to obtain another thread&rsquo;s lock, and this status will not change until one thread discards its lock.</p>

<p>线程A需要获取线程B的锁,而且B的锁需要获取A的锁.在线程转储文件里,你可以看到 线程DEADLOCK_TEST-1 持有锁0x00000007d58f5e48,并试图获取 锁0x00000007d58f5e60. 你还能看到 线程DEADLOCK_TEST-2 持有 锁0x00000007d58f5e60, 并试图获取 锁0x00000007d58f5e78. 同样, 线程DEADLOCK_TEST-3 持有 锁0x00000007d58f5e78, 并试图获取 锁0x00000007d58f5e48. 和你看到的一样, 每个线程都在等着获取其它线程的锁, 这个状态保持不变, 除非有个线程放弃了它的锁.</p>

<p><img src="/images/when-in-deadlock-status.png" alt="Alt text" /></p>

<p>Figure 4: Threads in a Deadlock status.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"DEADLOCK_TEST-1" daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting for monitor entry [0x000000000805f000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)
</span><span class='line'>    - waiting to lock &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)
</span><span class='line'>    - locked &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - None
</span><span class='line'>
</span><span class='line'>"DEADLOCK_TEST-2" daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting for monitor entry [0x000000000815f000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)
</span><span class='line'>    - waiting to lock &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)
</span><span class='line'>    - locked &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - None
</span><span class='line'>
</span><span class='line'>"DEADLOCK_TEST-3" daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting for monitor entry [0x000000000825f000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)
</span><span class='line'>    - waiting to lock &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)
</span><span class='line'>    - locked &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>                - None</span></code></pre></td></tr></table></div></figure>


<h4>When Continuously Waiting to Receive Messages from a Remote Server</h4>

<h4>持续等待接收远程服务器数据的时候</h4>

<p>The thread appears to be normal, since its state keeps showing as RUNNABLE. However, when you align the thread dumps chronologically, you can see that socketReadThread thread is waiting infinitely to read the socket.</p>

<p>因为线程的状态一直是 RUNNABLE ,所以它看起来很正常. 然而, 当你把多个线程转出文件按时间顺序排列, 你可以看到线程 socketReadThread 在无限等待读取socket.</p>

<p><img src="/images/when-continuosly-waiting-to-receive-message-from-remote-server.png" alt="Alt text" /></p>

<p>Figure 5: Continuous Waiting Status.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"socketReadThread" prio=6 tid=0x0000000006a0d800 nid=0x1b40 runnable [0x00000000089ef000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at java.net.SocketInputStream.socketRead0(Native Method)
</span><span class='line'>    at java.net.SocketInputStream.read(SocketInputStream.java:129)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)
</span><span class='line'>    - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.read0(StreamDecoder.java:107)
</span><span class='line'>    - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:93)
</span><span class='line'>    at java.io.InputStreamReader.read(InputStreamReader.java:151)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadSocketReadState$1.run(ThreadSocketReadState.java:27)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)</span></code></pre></td></tr></table></div></figure>


<h4>When Waiting</h4>

<h4>等待的时候</h4>

<p>The thread is maintaining WAIT status. In the thread dump, IoWaitThread thread keeps waiting to receive a message from LinkedBlockingQueue. If there continues to be no message for LinkedBlockingQueue, then the thread status will not change.</p>

<p>线程处于 WAIT 状态. 线程转储文件里, 线程IoWaitThread 一直等待来自 LinkedBlockingQueue 的消息. 如果 LinkedBlockingQueue 没有消息, 那么线程的状态就不会改变.</p>

<p><img src="/images/when-waiting.png" alt="Alt text" /></p>

<p>Figure 6: Waiting status.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"IoWaitThread" prio=6 tid=0x0000000007334800 nid=0x2b3c waiting on condition [0x000000000893f000]
</span><span class='line'>   java.lang.Thread.State: WAITING (parking)
</span><span class='line'>    at sun.misc.Unsafe.park(Native Method)
</span><span class='line'>    - parking to wait for  &lt;0x00000007d5c45850&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
</span><span class='line'>    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)
</span><span class='line'>    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)
</span><span class='line'>    at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:440)
</span><span class='line'>    at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:629)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadIoWaitState$IoWaitHandler2.run(ThreadIoWaitState.java:89)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)</span></code></pre></td></tr></table></div></figure>


<h4>When Thread Resources Cannot be Organized Normally</h4>

<h4>线程资源管理失控的时候</h4>

<p>Unnecessary threads will pile up when thread resources cannot be organized normally. If this occurs, it is recommended to monitor the thread organization process or check the conditions for thread termination.</p>

<p>如果不能有效地管理线程资源,那么一些不必要的线程就因为没有被销毁而越来越多. 发生这种状况的时候, 应该检查负责线程管理的线程,或者检查线程停止条件.</p>

<p><img src="/images/when-thread-resources-cannot-be-organized-normally.png" alt="Alt text" /></p>

<p>Figure 7: Unorganized Threads.</p>

<h3>How to Solve Problems by Using Thread Dump</h3>

<h3>如何用线程转储解决问题</h3>

<h4>Example 1: When the CPU Usage is Abnormally High</h4>

<h4>例 1: CPU使用率过高</h4>

<ol>
<li><p>Extract the thread that has the highest CPU usage.</p>

<p> 找出哪个线程占用了最多的CPU资源.</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ ps -mo pid.lwp.stime.time.cpu -C java
</span><span class='line'>      PID         LWP          STIME          TIME               %CPU
</span><span class='line'>     10029          -         Dec07          00:02:02           99.5
</span><span class='line'>         -       10039        Dec07          00:00:00            0.1
</span><span class='line'>         -       10040        Dec07          00:00:00           95.5</span></code></pre></td></tr></table></div></figure>


<p>From the application, find out which thread is using the CPU the most.</p>

<p>Acquire the Light Weight Process (LWP) that uses the CPU the most and convert its unique number (10039) into a hexadecimal number (0x2737).</p>

<p>找出应用里最占用CPU的那个线程,并获得它的轻量进程 Light Weight Process (LWP). 把这个唯一的LWP数字 (10039) 转成十六进制 (0x2737).</p>

<ol>
<li><p>After acquiring the thread dump, check the thread&rsquo;s action.</p>

<p> 得到线程转储文件之后, 检查线程执行的动作.</p></li>
</ol>


<p>Extract the thread dump of an application with a PID of 10029, then find the thread with an nid of 0x2737.</p>

<p>把PID为10029的应用进行线程转储, 然后找到nid为 0x2737 的线程.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"NioProcessor-2" prio=10 tid=0x0a8d2800 nid=0x2737 runnable [0x49aa5000] java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
</span><span class='line'>    at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:210)
</span><span class='line'>    at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:65)
</span><span class='line'>    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:69)
</span><span class='line'>    - locked &lt;0x74c52678&gt; (a sun.nio.ch.Util$1)
</span><span class='line'>    - locked &lt;0x74c52668&gt; (a java.util.Collections$UnmodifiableSet)
</span><span class='line'>    - locked &lt;0x74c501b0&gt; (a sun.nio.ch.EPollSelectorImpl)
</span><span class='line'>    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:80)
</span><span class='line'>    at external.org.apache.mina.transport.socket.nio.NioProcessor.select(NioProcessor.java:65)
</span><span class='line'>    at external.org.apache.mina.common.AbstractPollingIoProcessor$Worker.run(AbstractPollingIoProcessor.java:708)
</span><span class='line'>    at external.org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)</span></code></pre></td></tr></table></div></figure>


<p>Extract thread dumps several times every hour, and check the status change of the threads to determine the problem.</p>

<p>按一小时的时间间隔获取多个线程转储文件, 查看线程状态的变化来定位问题.</p>

<h4>Example 2: When the Processing Performance is Abnormally Slow</h4>

<h4>例 2: 应用的效率过低</h4>

<p>After acquiring thread dumps several times, find the list of threads with BLOCKED status.</p>

<p>获取多个线程转储文件之后, 找到状态为 BLOCKED 的所有线程.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> "DB-Processor-13" daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f000]
</span><span class='line'>java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at beans.ConnectionPool.getConnection(ConnectionPool.java:102)
</span><span class='line'>    - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)
</span><span class='line'>    at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)
</span><span class='line'>    at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)
</span><span class='line'>
</span><span class='line'>"DB-Processor-14" daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f020]
</span><span class='line'>java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at beans.ConnectionPool.getConnection(ConnectionPool.java:102)
</span><span class='line'>    - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)
</span><span class='line'>    at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)
</span><span class='line'>    at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)
</span><span class='line'>
</span><span class='line'>"" "DB-Processor-3"" daemon prio=5 tid=0x00928248 nid=0x8b waiting for monitor entry [0x000000000825d080]
</span><span class='line'>java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at oracle.jdbc.driver.OracleConnection.isClosed(OracleConnection.java:570)
</span><span class='line'>    - waiting to lock &lt;0xe03ba2e0&gt; (a oracle.jdbc.driver.OracleConnection)
</span><span class='line'>    at beans.ConnectionPool.getConnection(ConnectionPool.java:112)
</span><span class='line'>    - locked &lt;0xe0386580&gt; (a java.util.Vector)
</span><span class='line'>    - locked &lt;0xe0375410&gt; (a beans.ConnectionPool)
</span><span class='line'>    at beans.cus.Cue_1700c.GetNationList(Cue_1700c.java:66)
</span><span class='line'>    at org.apache.jsp.cue_1700c_jsp._jspService(cue_1700c_jsp.java:12)</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Acquire the list of threads with BLOCKED status after getting the thread dumps several times.</p>

<p> If the threads are BLOCKED, extract the threads related to the lock that the threads are trying to obtain.</p>

<p>Through the thread dump, you can confirm that the thread status stays BLOCKED because <0xe0375410> lock could not be obtained. This problem can be solved by analyzing stack trace from the thread currently holding the lock.</p>

<p>There are two reasons why the above pattern frequently appears in applications using DBMS. The first reason is inadequate configurations. Despite the fact that the threads are still working, they cannot show their best performance because the configurations for DBCP and the like are not adequate. If you extract thread dumps multiple times and compare them, you will often see that some of the threads that were BLOCKED previously are in a different state.</p>

<p>The second reason is the abnormal connection. When the connection with DBMS stays abnormal, the threads wait until the time is out. In this case, even after extracting the thread dumps several times and comparing them, you will see that the threads related to DBMS are still in a BLOCKED state. By adequately changing the values, such as the timeout value, you can shorten the time in which the problem occurs.</p>

<p>如果线程处于 BLOCKED 状态, 首先查找阻塞它的锁, 然后把和这个锁有关的线程找出来. 从上面的转储文件里, 你可以看到处于 BLOCKED 状态的线程, 她想获得锁 <0xe0375410>. 这个问题可以通过分析持有锁的线程的调用栈来解决. 使用DBMS的应用会频繁地出现上述问题, 原因有两个. 一是配置不完善. 尽管线程可以运行, 但是类似DBCP等选项没有被正确配置,所以达不到最高的效率. 如果获取多个线程转储文件并比较它们, 你会发现处于 BLOCKED 状态的线程之前是其它状态. 二是连接异常. 如果与DBMS的连接异常, 线程会一直等到超时. 这种情况下, 导出并比较多个转储文件, 你会发现和DBMS有关的线程仍然处于 BLOCKED 状态. 通过多次调整参数, 比如超时时间, 你可以缩短上述问题发生的时间.</p>

<h3>Coding for Easy Thread Dump</h3>

<h3>有利于线程转储的编码方式</h3>

<h4>Naming Threads</h4>

<h4>给线程命名</h4>

<p>When a thread is created using java.lang.Thread object, the thread will be named Thread-(Number). When a thread is created using java.util.concurrent.DefaultThreadFactory object, the thread will be named pool-(Number)-thread-(Number). When analyzing tens to thousands of threads for an application, if all the threads still have their default names, analyzing them becomes very difficult, because it is difficult to distinguish the threads to be analyzed.</p>

<p>使用java.lang.Thread 创建线程时, 线程被命名为 Thread-(序号). 使用java.util.concurrent.DefaultThreadFactory 创建线程, 线程被命名为 pool-(序号)-thread-(序号). 如果应用有成百上千的线程, 这些线程都使用默认的命名, 分析这些线程就变得困难, 因为区分这些线程不是一件容易的事.</p>

<p>Therefore, you are recommended to develop the habit of naming the threads whenever a new thread is created.</p>

<p>所以,要养成给线程命名的好习惯.</p>

<p>When you create a thread using java.lang.Thread, you can give the thread a custom name by using the creator parameter.</p>

<p>使用 java.lang.Thread时, 通过构造函数给线程一个定制的名字.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Thread(Runnable target, String name);
</span><span class='line'>public Thread(ThreadGroup group, String name);
</span><span class='line'>public Thread(ThreadGroup group, Runnable target, String name);
</span><span class='line'>public Thread(ThreadGroup group, Runnable target, String name, long stackSize);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>When you create a thread using java.util.concurrent.ThreadFactory, you can name it by generating your own ThreadFactory. If you do not need special functionalities, then you can use MyThreadFactory as described below:</p>

<p>使用 java.util.concurrent.ThreadFactory时, 可以自己实现一个ThreadFactory. 如果没有特殊的需求, 下面的例子就足够了.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import java.util.concurrent.ConcurrentHashMap;
</span><span class='line'>import java.util.concurrent.ThreadFactory;
</span><span class='line'>import java.util.concurrent.atomic.AtomicInteger;
</span><span class='line'> 
</span><span class='line'>public class MyThreadFactory implements ThreadFactory {
</span><span class='line'>  private static final ConcurrentHashMap&lt;String, AtomicInteger&gt; POOL_NUMBER =
</span><span class='line'>                                                       new ConcurrentHashMap&lt;String, AtomicInteger&gt;();
</span><span class='line'>  private final ThreadGroup group;
</span><span class='line'>  private final AtomicInteger threadNumber = new AtomicInteger(1);
</span><span class='line'>  private final String namePrefix;
</span><span class='line'>  
</span><span class='line'>  public MyThreadFactory(String threadPoolName) {
</span><span class='line'>       
</span><span class='line'>      if (threadPoolName == null) {
</span><span class='line'>          throw new NullPointerException("threadPoolName");
</span><span class='line'>      }
</span><span class='line'>        
</span><span class='line'>      POOL_NUMBER.putIfAbsent(threadPoolName, new AtomicInteger());
</span><span class='line'>       
</span><span class='line'>      SecurityManager securityManager = System.getSecurityManager();
</span><span class='line'>      group = (securityManager != null) ? securityManager.getThreadGroup() :
</span><span class='line'>                                                    Thread.currentThread().getThreadGroup();
</span><span class='line'>       
</span><span class='line'>      AtomicInteger poolCount = POOL_NUMBER.get(threadPoolName);
</span><span class='line'> 
</span><span class='line'>      if (poolCount == null) {
</span><span class='line'>            namePrefix = threadPoolName + " pool-00-thread-";
</span><span class='line'>      } else {
</span><span class='line'>            namePrefix = threadPoolName + " pool-" + poolCount.getAndIncrement() + "-thread-";
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public Thread newThread(Runnable runnable) {
</span><span class='line'>      Thread thread = new Thread(group, runnable, namePrefix + threadNumber.getAndIncrement(), 0);
</span><span class='line'> 
</span><span class='line'>      if (thread.isDaemon()) {
</span><span class='line'>            thread.setDaemon(false);
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>      if (thread.getPriority() != Thread.NORM_PRIORITY) {
</span><span class='line'>            thread.setPriority(Thread.NORM_PRIORITY);
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>      return thread;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Obtaining More Detailed Information by Using MBean</h4>

<h4>通过MBean获得更详细的信息</h4>

<p>You can obtain ThreadInfo objects using MBean. You can also obtain more information that would be difficult to acquire via thread dumps, by using ThreadInfo.</p>

<p>你可以使用MBean获得ThreadInfo对象. 你也可以使用ThreadInfo来获得一些信息, 而线程转储的方式很难获取这些信息.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
</span><span class='line'>long[] threadIds = mxBean.getAllThreadIds();
</span><span class='line'>ThreadInfo[] threadInfos = mxBean.getThreadInfo(threadIds);
</span><span class='line'> 
</span><span class='line'>for (ThreadInfo threadInfo : threadInfos) {
</span><span class='line'>  System.out.println(threadInfo.getThreadName());
</span><span class='line'>  System.out.println(threadInfo.getBlockedCount());
</span><span class='line'>  System.out.println(threadInfo.getBlockedTime());
</span><span class='line'>  System.out.println(threadInfo.getWaitedCount());
</span><span class='line'>  System.out.println(threadInfo.getWaitedTime());
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>You can acquire the amount of time that the threads WAITed or were BLOCKED by using the method in ThreadInfo, and by using this you can also obtain the list of threads that have been inactive for an abnormally long period of time.</p>

<p>你可以方便地得到线程处于 WAIT 和 BLOCKED 状态的时间, 由此你可以获得那些长期处于不活动状态的线程列表.</p>

<h3>In Conclusion</h3>

<h3>结论</h3>

<p>In this article I was concerned that for developers with a lot of experience in multi-thread programming, this material may be common knowledge, whereas for less experienced developers, I felt that I was skipping straight to thread dumps, without providing enough background information about the thread activities. This was because of my lack of knowledge, as I was not able to explain the thread activities in a clear yet concise manner. I sincerely hope that this article will prove helpful for many developers.</p>

<p>这篇文章总结了处理多线程的常识性的经验, 对这方面有很多经验的人来说可能帮助不大. 对新人来说, 我感觉我在开门见山地讲线程转储, 而略过了线程活动的背景知识. 这是因为我缺少这方面的经验, 不能简单扼要地进行阐述. 我真诚地希望这篇文章能够帮助更多的人.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/14/angularjs-1th-taste/">AngularJs的初次体验</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-14T23:41:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2013/08/14/angularjs-1th-taste/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h6>用angularjs来实现个啥东西？</h6>

<ul>
<li>右边为列表的展示</li>
<li>左边search栏为输入筛选的字段，对应的列表展示筛选的结果。</li>
<li>左边Sort by 栏为选择排序值，对应的列表展示排序结果。</li>
<li>Reverse Searchd的值是search input框值得逆序。（可以通过穿件directive或者filter）。</li>
<li>点击莫个链接，改变hash值来切换模块，展现不同的页面。（利用n-view或者ng-include指令）。</li>
</ul>


<h6>需要用到的指令以及筛选filter</h6>

<ol>
<li>ng-app</li>
<li>ng-repeat</li>
<li>ng-model</li>
<li>ng-view</li>
<li>filter</li>
<li>orderBy</li>
<li>自定义指令ngreverse</li>
</ol>


<h6>代码示例</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>City:<span class="p">&lt;</span><span class="n">input</span> ng-model<span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="n">/&gt;</span>
</span><span class='line'>City reverse:<span class="p">&lt;</span><span class="n">span</span> ngreverse<span class="o">=</span><span class="s2">&quot;city&quot;</span> style<span class="o">=</span><span class="s2">&quot;color:red;&quot;</span>&gt;&lt;<span class="n">/span&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>appModule.directive(<span class="s1">&#39;ngreverse&#39;</span><span class="p">,</span> function() {
</span><span class='line'>      return function(scope<span class="p">,</span> element<span class="p">,</span> attrs){
</span><span class='line'>          scope.$watch(attrs.ngreverse<span class="p">,</span> function(value) {
</span><span class='line'>              value <span class="o">=</span> value <span class="o">==</span> undefined ? <span class="s2">&quot;&quot;</span> : value;
</span><span class='line'>              element.text(reverse(value));
</span><span class='line'>          });
</span><span class='line'>      };
</span><span class='line'>  });
</span></code></pre></td></tr></table></div></figure>


<h6>代码实现细节</h6>

<ul>
<li>$routeProvider</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>var appModule <span class="o">=</span> angular.module(<span class="s1">&#39;phonecat&#39;</span><span class="p">,</span> []);
</span><span class='line'>appModule.config(
</span><span class='line'>  [<span class="s1">&#39;$routeProvider&#39;</span><span class="p">,</span> function($routeProvider) {
</span><span class='line'>      $routeProvider.when(<span class="s1">&#39;/&#39;</span><span class="p">,</span> {
</span><span class='line'>          templateUrl: <span class="s1">&#39;phone-list.html&#39;</span><span class="p">,</span>
</span><span class='line'>          controller: PhoneListCtrl
</span><span class='line'>      }).when(<span class="s1">&#39;/:phoneId/:phoneAge&#39;</span><span class="p">,</span> {
</span><span class='line'>          templateUrl: <span class="s1">&#39;phone-detail.html&#39;</span><span class="p">,</span>
</span><span class='line'>          controller: PhoneDetailCtrl
</span><span class='line'>      }).otherwise({redirectTo: <span class="s1">&#39;/&#39;</span>});
</span><span class='line'>  }]);
</span></code></pre></td></tr></table></div></figure>


<h6>实现效果</h6>

<p><img src="/images/qq-20130824094417.jpg" width="650" height="350" title="image" alt="images"></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/20/maven-release-plugin-best-practice/">Maven-release-plugin 实践</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-20T08:50:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2013/07/20/maven-release-plugin-best-practice/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>maven-release-plugin简介</h4>

<p>该插件是maven自带的用于发布项目之用，比如我们用SCM的svn来管理源代码，一般会分为trunk/branches/tags三个目录。
trunk对应主线开发，一般对应的是SNAPSHOT版本，而branches可以是从trunk copy to的一个修复的小版本，也可以是从
tags copy to的一个要修复的版本，同样对应的是SNAPSHOT版本。仅有tags下面的项目的版本号定义为release。
至于maven下的release与snapshot的区别，不清楚的同学可以猛击:<a href="http://www.mzone.cc/article/277.html">http://www.mzone.cc/article/277.html</a></p>

<p>官网地址: <a href="http://maven.apache.org/maven-release/maven-release-plugin/">http://maven.apache.org/maven-release/maven-release-plugin/</a></p>

<h4>如何用好maven-release-plugin</h4>

<p>在实际开发中，为了方便修复bug，以及准备测试程序包。按照规范流程都需要将开发程序打包成tag，然后将程序发布出去。
那么我就经常需要从 1.0-SNAPSHOT到1.0到1.1-SNAPSHOT 这样的操作。对于项目个数比较少的情况，手动修改也未尝不可。
对于比较复杂的系统，分成了大量的服务，业务模块的，少则7，8个多者20+个。笔者在实际应用中的就是包含有20多个工程。
在没有应用release插件的时候，基本上负责发布的同学很头疼，也想办法用shell脚本去改pom的版本号。但是还是稍显麻烦。</p>

<h4>1.0-SNAPSHOT到1.0到1.1-SNAPSHOT</h4>

<p>SNAPSHOT是快照的意思，项目到一个阶段后，就需要发布一个正式的版本（release版本）。一次正式的发布需要这样一些工作：</p>

<pre><code>在trunk中，更新pom版本从1.0-SNAPSHOT到1.0
对1.0打一个svn tag
针对tag进行mvn deploy，发布正式版本
更新trunk从1.0到1.1-SNAPSHOT
</code></pre>

<h4>SCM</h4>

<p>首先我们需要在POM中加入scm信息，这样Maven才能够替你完成svn操作，示例配置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="p">&lt;</span><span class="n">scm</span>&gt;
</span><span class='line'>  <span class="p">&lt;</span><span class="n">connection</span><span class="p">&gt;</span><span class="n">scm</span><span class="nl">:svn:http</span>:<span class="n">//svn地址前缀部分/myapp/trunk/&lt;/connection&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">developerConnection</span><span class="p">&gt;</span><span class="n">scm</span><span class="nl">:svn:http</span>:<span class="n">//svn地址前缀部分/myapp/trunk/&lt;/developerConnection&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">url</span><span class="p">&gt;</span><span class="n">scm</span><span class="nl">:svn:http</span>:<span class="n">//svn地址前缀部分/myapp/trunk/&lt;/url&gt;</span>
</span><span class='line'>&lt;<span class="n">/scm&gt;</span>
</span><span class='line'>这样的配置是对应trunk下pom的配置，各个branches和tags都不一样，需要是其对于的svn地址
</span></code></pre></td></tr></table></div></figure>


<h4>maven-release-plugin 应用配置</h4>

<p>紧接着，我们需要配置maven-release-plugin，这个插件会帮助我们升级pom版本，提交，打tag，然后再升级版本，再提交，等等。配置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="p">&lt;</span><span class="n">plugin</span>&gt;
</span><span class='line'>  <span class="p">&lt;</span><span class="n">groupId</span><span class="p">&gt;</span><span class="n">org</span>.apache.maven.plugins&lt;<span class="n">/groupId&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">artifactId</span><span class="p">&gt;</span><span class="n">maven</span>-release-plugin&lt;<span class="n">/artifactId&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">version</span><span class="p">&gt;</span><span class="n">2</span>.<span class="m">4</span>.<span class="m">1</span>&lt;<span class="n">/version&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">configuration</span>&gt;
</span><span class='line'>      &lt;!-- mvn release:branch -DbranchName<span class="o">=</span>xxx -DupdateBranchVersions<span class="o">=</span>true
</span><span class='line'>                      -DupdateWorkingCopyVersion<span class="o">=</span>false --&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">branchBase</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//svn地址前缀部分/myapp/branches&lt;/branchBase&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">arguments</span>&gt;
</span><span class='line'>          -Dmaven.test.skip<span class="o">=</span>true
</span><span class='line'>      &lt;<span class="n">/arguments&gt;</span>
</span><span class='line'>
</span><span class='line'>      &lt;!-- mvn release:perform -DautoVersionSubmodules<span class="o">=</span>true -DupdateWorkingCopyVersion<span class="o">=</span>false --&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">tagBase</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//svn地址前缀部分/myapp/tags&lt;/tagBase&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">waitBeforeTagging</span><span class="p">&gt;</span><span class="n">10</span>&lt;<span class="n">/waitBeforeTagging&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">username</span>&gt;${svn.username}&lt;<span class="n">/username&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">password</span>&gt;${svn.password}&lt;<span class="n">/password&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">mavenHome</span>&gt;${svn.maven.home}&lt;<span class="n">/mavenHome&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">scmCommentPrefix</span><span class="p">&gt;</span>
</span><span class='line'><span class="n">issue</span><span class="nl">:maven</span>-release-plugin
</span><span class='line'>msg:excute maven-release-plugin
</span><span class='line'>      &lt;<span class="n">/scmCommentPrefix&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">autoVersionSubmodules</span><span class="p">&gt;</span><span class="n">true</span>&lt;<span class="n">/autoVersionSubmodules&gt;</span>
</span><span class='line'>  &lt;<span class="n">/configuration&gt;</span>
</span><span class='line'>&lt;<span class="n">/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的配置可以知道，需要配置svn提交的用户名和密码以及svn安装目录，还有就是svn提交的注释(可选)。
另外在release插件打包发布到似有远程仓库的部分需要配置:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="p">&lt;</span><span class="n">distributionManagement</span>&gt;
</span><span class='line'>  <span class="p">&lt;</span><span class="n">repository</span>&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">id</span><span class="p">&gt;</span><span class="n">nexus</span>&lt;<span class="n">/id&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">name</span><span class="p">&gt;</span><span class="n">Nexus</span>&lt;<span class="n">/name&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">url</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//ci仓库域名/nexus/content/repositories/releases&lt;/url&gt;</span>
</span><span class='line'>  &lt;<span class="n">/repository&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">snapshotRepository</span>&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">id</span><span class="p">&gt;</span><span class="n">nexus</span>&lt;<span class="n">/id&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">name</span><span class="p">&gt;</span><span class="n">Nexus</span>&lt;<span class="n">/name&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">url</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//ci仓库域名/nexus/content/repositories/snapshots&lt;/url&gt;</span>
</span><span class='line'>  &lt;<span class="n">/snapshotRepository&gt;</span>
</span><span class='line'>&lt;<span class="n">/distributionManagement&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>执行、操作 Action</h4>

<h6>mvn release:prepare</h6>

<blockquote><p>执行过程中，你会遇到这样的提示：</p>

<p>What is the release version for &ldquo;Unnamed - org.myorg:myapp:jar:1.0-SNAPSHOT&rdquo;? (org.myorg:myapp) 1.0: :</p>

<p>——“你想将1.0-SNAPSHOT发布为什么版本？默认是1.0。”我要的就是1.0，直接回车。</p>

<p>What is SCM release tag or label for &ldquo;Unnamed - org.myorg:myapp:jar:1.0-SNAPSHOT&rdquo;? (org.myorg:myapp) myapp-1.0: :</p>

<p>——“发布的tag标签名称是什么？默认为myapp-1.0。”我还是要默认值，直接回车。</p>

<p>What is the new development version for &ldquo;Unnamed - org.myorg:myapp:jar:1.0-SNAPSHOT&rdquo;? (org.myorg:myapp) 1.1-SNAPSHOT: :</p>

<p>——“主干上新的版本是什么？默认为1.1-SNAPSHOT。”哈，release插件会自动帮我更新版本到1.1-SNAPSHOT，很好，直接回车。</p>

<p>然后屏幕刷阿刷，maven在build我们的项目，并进行了一些svn操作，你可以仔细查看下日志。</p>

<p>那么结果是什么呢？你可以浏览下svn仓库：</p>

<p>   我们多了一个tag：<a href="https://svn-address.com/myapp/tags/myapp-1.0/">https://svn-address.com/myapp/tags/myapp-1.0/</a>  这就是需要发布的版本1.0。
   再看看trunk中的POM，其版本自动升级成了1.1-SNAPSHOT。</p>

<p>这不正是我们想要的么？等等，好像缺了点什么，对了，1.0还没有发布到仓库中呢。</p>

<p>再一次屏住呼吸，执行：</p></blockquote>

<h6>mvn release:perform</h6>

<blockquote><p>maven-release-plugin会自动帮我们签出刚才打的tag，然后打包，分发到远程Maven仓库中，至此，整个版本的升级，打标签，发布等工作全部完成。我们可以在远程Maven仓库中看到正式发布的1.0版本。</p>

<p>这可是自动化的 ，正式的 版本发布！</p></blockquote>

<h4>注意点</h4>

<p>svn client的版本号，1.6的版本执行的时候需要手动确认版本号， 1.7不需要。</p>

<p>maven项目中的依赖其他的jar包，不能是SNAPSHOT版本的。(同时开发的项目可以用module的形式引入)。</p>

<p>从trunk打branches、tags以及从tags打branches、或者从branches打tags以上命令都支持，一般执行release:perform都需要先执行release:prepare.</p>

<p>修改trunk的版本号或者branches的版本号，可以用release:update-versions命令。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/05/wiremock-example-for-maven/">Wiremock在maven环境下的应用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-05T22:18:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2013/07/05/wiremock-example-for-maven/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>wiremock是什么</h4>

<p><em>wiremock</em>是一个用来做Web服务存根和<em>mock</em>的灵活工具库。与常用的<em>mock</em>工具不一样的是，<em>wiremock</em>通过创建一个真实的http服务，让你的代码在测试上可以连接到真正的Web服务</p>

<p>它支持HTTP响应存根,请求验证,代理/拦截,记录/回放的存根和故障注入,可以从内部使用单元测试或部署到测试环境。</p>

<p>尽管是用java编写的，有一套<em>Json api</em>可以与其他语言完美结合使用。</p>

<p>官方地址:<a href="http://wiremock.org/">http://wiremock.org/</a></p>

<h4>解决了什么问题</h4>

<p>在大前端的推动下，不少web系统采用前端和后端分离架构，前端只需要调用<em>restful</em>服务API即可拿到交互数据。在约定好api接口后，web开发团和API服务团队可以并行开发。
可以让各司其职，各自处理自己擅长的部分，让事情做起来更高效。</p>

<h4>maven support</h4>

<h6>1.    需要将前端代码独立成一个web maven项目。</h6>

<p>需要按wiremock的方式放置文件目录:需要保包含<em>__files</em>和<em>mapping</em>目录。当<em>wiremock</em>以文件的方式进行独立运行时，
需要将文件放置在<em>__files</em>目录下用来作为文档根目录。而<em>mapping</em>目录作为映射请求url的json数据存储目录以及定义url和json数据的映射关系。</p>

<p>目录组织方式如下图</p>

<p><img src="/images/front_end_dir.jpg" width="350" height="350" title="image" alt="images"></p>

<p>pom.xml的配置片段</p>

<p><img src="/images/front_pom.jpg" width="350" height="350" title="image" alt="images"></p>

<h6>2.    将整个应用程序集成的一个web maven项目。</h6>

<p><img src="/images/war_integration_pom.jpg" width="350" height="350" title="image" alt="images"></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/02/octopress-in-github-pages/">Github上安装octopress博客</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-02T21:09:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2013/07/02/octopress-in-github-pages/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>周末闲来无事，学习了一下怎样利用github pages来建立自己的博客，现在比较成熟的博客系统是Octopress，关于其详细的介绍可以参见官方文档。
本文安装是基于window xp 32系统，参考地址:<a href="http://jinlong.github.io/blog/2013/03/15/deploy-github-pages-using-octopress-on-windows/">http://jinlong.github.io/blog/2013/03/15/deploy-github-pages-using-octopress-on-windows/</a></p>

<ol>
<li>已拥有github账号 没有的同学可以去 <a href="https://github.com">https://github.com</a> 上申请。</li>
<li>需要在window机器上安装Git 安装好Git后，安装目录下提供了一个叫Git Bash的cmd工具</li>
<li>安装ruby环境 rvm在window下没法安装，以及替代安装工具Pik的安装也需要依赖rubygems工具。所以最后选择RubyInstaller安装程序，一键安装。 安装好后，需要将其配置在环境变量->系统变量的Path中</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>*.;C:\Ruby<span class="m">193</span>\bin;C:\Program Files\Git\bin;C:\Program Files\Git\cmd
</span></code></pre></td></tr></table></div></figure>


<p>安装DevKit，ruby的一个开发工具集
更新配置 中文 utf-8 编码的支持，在win7环境变量中配置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>LANG<span class="o">=</span>zh_CN.UTF<span class="m">-8</span>
</span><span class='line'>LC_ALL<span class="o">=</span>zh_CN.UTF<span class="m">-8</span>
</span></code></pre></td></tr></table></div></figure>


<p>变更 gem 的更新源，变更如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>gem sources --remove http:<span class="n">//rubygems.org/</span>
</span><span class='line'>gem sources -a http:<span class="n">//ruby.taobao.org/</span>
</span><span class='line'>gem sources -l
</span></code></pre></td></tr></table></div></figure>


<p>进入Git Bash cmd，执行如下命令安装bundler</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>gem install bundler
</span></code></pre></td></tr></table></div></figure>


<p>安装Octopress 下载Octopress源代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>git clone git:<span class="n">//github.com/imathis/octopress.git</span> octopress
</span><span class='line'><span class="k">cd</span> octopress # <span class="k">If</span> you use RVM<span class="p">,</span> You&#39;ll be asked <span class="k">if</span> you trust the .rvmrc file (say yes).
</span><span class='line'>ruby --version # Should report Ruby <span class="m">1</span>.<span class="m">9</span>.<span class="m">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>安装依赖模块</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="k">cd</span> octopress
</span><span class='line'>vi GemFile
</span><span class='line'>将行 ： source <span class="s2">&quot;http://rubygems.org/&quot;</span>
</span><span class='line'>改为 ： source <span class="s2">&quot;http://ruby.taobao.org/&quot;</span>
</span><span class='line'>$ bundle install
</span></code></pre></td></tr></table></div></figure>


<p>安装默认主题</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake install
</span></code></pre></td></tr></table></div></figure>


<p>发布到github上</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake setup_github_pages # 会提示要输入对应的github地址，例如 https:<span class="n">//github.com/yangtao309/yangtao309.github.com.git</span>
</span></code></pre></td></tr></table></div></figure>


<p>生成博客系统以及预览</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake generate # 生成文件
</span><span class='line'>rake preview  # 预览系统，默认访问地址 http:<span class="n">//127.0.0.1:4000</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后就是提交代码到github</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake deploy # 会提示输入github的账号和密码信息
</span></code></pre></td></tr></table></div></figure>


<p>简单的octopress搭建就算完成了。后面就是些blog内容和安装分享插件bshare和微博右侧栏、以及新的主题替换啦。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/18/karaf-ying-yong-zhong-ru-he-pei-zhi-shu-ju-yuan/">Karaf 应用中如何配置数据源</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/understanding-java-garbage-collection/">Understanding Java Garbage Collection</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/how-to-analyze-java-thread-dumps/">How to Analyze Java Thread Dumps</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/14/angularjs-1th-taste/">AngularJs的初次体验</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/20/maven-release-plugin-best-practice/">Maven-release-plugin 实践</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/yangtao309">@yangtao309</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'yangtao309',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>	<h1>新浪微博</h1>	<ul id="weibo">		<li>			<iframe 				width="100%" 				height="550" 				class="share_self"  				frameborder="0" 				scrolling="no" 				src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=1&isFans=1&uid=1692592813&verifier=b001128f&dpc=1"></iframe>		</li>	</ul></section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - samung -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'yangtao309';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
