<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keep It Simple, Stupid]]></title>
  <link href="http://yangtao309.github.io/atom.xml" rel="self"/>
  <link href="http://yangtao309.github.io/"/>
  <updated>2014-08-17T19:00:17+08:00</updated>
  <id>http://yangtao309.github.io/</id>
  <author>
    <name><![CDATA[samung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Analyze Java Thread Dumps]]></title>
    <link href="http://yangtao309.github.io/blog/2014/08/17/how-to-analyze-java-thread-dumps/"/>
    <updated>2014-08-17T17:18:05+08:00</updated>
    <id>http://yangtao309.github.io/blog/2014/08/17/how-to-analyze-java-thread-dumps</id>
    <content type="html"><![CDATA[<p>The content of this article was originally written by Tae Jin Gu on the <a href="http://www.cubrid.org/blog/dev-platform/how-to-analyze-java-thread-dumps/">Cubrid blog</a>.</p>

<p>该文来源于Cubrid blog(不过源地址已没有相关内容，本文翻译系转载)</p>

<p>When there is an obstacle, or when a Java based Web application is running much slower than expected, we need to use <strong>thread dumps</strong>. If <strong>thread dumps</strong> feel like very complicated to you, this article may help you very much. Here I will explain what threads are in Java, their types, how they are created, how to manage them, how you can dump threads from a running application, and finally how you can analyze them and determine the bottleneck or blocking threads. This article is a result of long experience in Java application debugging.</p>

<p>当Java程序遇到了麻烦,或者Java编写的Web应用运行得比预期情况慢,就可以使用<strong>thread dumps</strong>这一利器分析问题.如果你觉得<strong>thread dumps</strong>很复杂,那么阅读本文会对你有所帮助.本文将介绍什么是Java线程,线程的种类,如何创建,如何管理,如何对正在运行的程序进行<strong>thread dumps</strong>,如何分析,最终找到瓶颈或阻塞线程.本文总结了长期调试Java程序的经验.</p>

<h2>Java and Thread</h2>

<h2>java和线程</h2>

<p>A web server uses tens to hundreds of threads to process a large number of concurrent users. If two or more threads utilize the same resources, a contention between the threads is inevitable, and sometimes deadlock occurs.</p>

<p>Web服务器通常创建很多线程去处理高并发的用户请求.如果两三个线程使用同样的服务器资源,线程间的竞争就不可避免了,更糟糕的情况下还会发生死锁.</p>

<p><strong>Thread contention</strong> is a status in which one thread is waiting for a lock, held by another thread, to be lifted. Different threads frequently access shared resources on a web application. For example, to record a log, the thread trying to record the log must obtain a lock and access the shared resources.</p>

<p><strong>线程竞争</strong>是指一个线程等待另一个线程持有的锁.Web服务的不同线程会频繁地访问共享资源,比如记录日志:一个试图记录日志的线程必须先获得锁才能访问共享资源.</p>

<p><strong>Deadlock</strong> is a special type of thread contention, in which two or more threads are waiting for the other threads to complete their tasks in order to complete their own tasks.</p>

<p><strong>死锁</strong>是线程竞争的一个特殊形式.多个线程都在等待其它线程先于自己完成任务,于是陷入无尽的等待.</p>

<p>Different issues can arise from <strong>thread contention</strong>. To analyze such issues, you need to use the <strong>thread dump</strong>. A thread dump will give you the information on the exact status of each thread.</p>

<p><strong>线程竞争</strong>会导致很多问题,我们需要使用<strong>thread dumps</strong>来解决,它会提供每个线程状态的确切信息.</p>

<h2>Background Information for Java Threads</h2>

<h2>Java线程的背景知识</h2>

<h3>Thread Synchronization</h3>

<h3>线程同步</h3>

<p>A thread can be processed with other threads at the same time. In order to ensure compatibility when multiple threads are trying to use shared resources, one thread at a time should be allowed to access the shared resources by using <strong>thread synchronization</strong>.</p>

<p>多个线程可以同时运行,为了让使用共享资源的多个线程可以和平共处,同一时刻只允许一个线程访问共享资源,这是通过<strong>线程同步</strong>来实现的.</p>

<p><strong>Thread synchronization</strong> on Java can be done using monitor. Every Java object has a single monitor. The monitor can be owned by only one thread. For a thread to own a monitor that is owned by a different thread, it needs to wait in the wait queue until the other thread releases its monitor.</p>

<p>Java<strong>线程同步</strong>使用了<a href="http://zh.wikipedia.org/zh-cn/%E7%9B%A3%E8%A6%96%E5%99%A8_%28%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96%29">管程</a>.每个Java对象都有一个管程.每个管程只能被一个线程持有.如果一个线程想持有另一个线程持有的管程,它需要排队等待另一个线程去释放锁.</p>

<h3>Thread Status</h3>

<h3>线程的状态</h3>

<p>In order to analyze a <strong>thread dump</strong>, you need to know the status of threads. The statuses of threads are stated on java.lang.Thread.State.</p>

<p>为了分析<strong>thread dump</strong>,我们需要知道线程的状态,这些状态用java.lang.Thread.State来表示:</p>

<p><img src="http://yangtao309.github.io/images/u404847178_13c476c51ffg85_blog.png" alt="Alt text" /></p>

<p> Figure 1: Thread Status.</p>

<ul>
<li>NEW: The thread is created but has not been processed yet.</li>
<li>RUNNABLE: The thread is occupying the CPU and processing a task. (It may be in WAITING status due to the OS&rsquo;s resource distribution.)</li>
<li>BLOCKED: The thread is waiting for a different thread to release its lock in order to get the monitor lock.</li>
<li>WAITING: The thread is waiting by using a wait, join or park method.</li>
<li><p>TIMED_WAITING: The thread is waiting by using a sleep, wait, join or park method. (The difference from WAITING is that the maximum waiting time is specified by the method parameter, andWAITING can be relieved by time as well as external changes.)</p></li>
<li><p>NEW: 线程已经被建立,但是还没有执行.</p></li>
<li>RUNNABLE: 线程正使用CPU来处理任务(因为操作系统的资源调度原因,线程可以处于WAITING状态)</li>
<li>BLOCKED: 线程正在等待另一个线程释放锁.</li>
<li>WAITING: 线程因为使用了wait, join 或 park 方法而处于等待状态.</li>
<li>TIMED_WAITING: 线程因为使用了sleep, wait, join 或 park 方法而处于等待状态. (和 WAITING 状态的区别是, 除了外部条件改变之外, 此状态有超时机制, 过了给定的最长等待时间, 此等待状态就解除了)</li>
</ul>


<h3>Thread Types</h3>

<h3>线程种类</h3>

<p>Java threads can be divided into two:</p>

<ol>
<li> daemon threads;</li>
<li> and non-daemon threads.</li>
</ol>


<p>Java的线程可分为两类:</p>

<ol>
<li> 监控线程</li>
<li> 非监控线程</li>
</ol>


<p>Daemon threads stop working when there are no other non-daemon threads. Even if you do not create any threads, the Java application will create several threads by default. Most of them are daemon threads, mainly for processing tasks such as garbage collection or JMX.</p>

<p>当没有其它非监控线程继续运行时,监控线程才会停止.即使你没有创建任何线程,Java程序也会创建几个默认线程.默认线程大多是监控线程,主要是为了垃圾回收或者JMX.</p>

<p>A thread running the &lsquo;static void main(String[] args)’ method is created as a non-daemon thread, and when this thread stops working, all other daemon threads will stop as well. (The thread running this main method is called the VM thread in HotSpot VM.)</p>

<p>Java线程同步使用了管程.每个Java对象都有一个管程.每个管程只能被一个线程持有.如果一个线程想持有另一个线程持有的管程,它需要在排队等待另一个线程去释放.执行main方法的线程时非监控线程,当它结束时,所有的监控线程也都要停止.(在HotSpot VM里,这个线程叫做VM Thread).</p>

<h3>Getting a Thread Dump</h3>

<h3>获取Thread Dump</h3>

<p>We will introduce the three most commonly used methods. Note that there are many other ways to get a thread dump. A thread dump can only show the thread status at the time of measurement, so in order to see the change in thread status, it is recommended to extract them from 5 to 10 times with 5-second intervals.</p>

<p>有很多种方法可以得到<strong>thread dump</strong>,我们将介绍最常见的三种方法.一个<strong>thread dump</strong>只能包含转储时刻的线程状态,所以为了分析线程状态的变化,最好每隔5秒获取一次,得到5~10个<strong>thread dump</strong>就可以了.</p>

<h4>Getting a Thread Dump Using jstack</h4>

<h4>使用jstack</h4>

<p>In JDK 1.6 and higher, it is possible to get a thread dump on MS Windows using jstack.</p>

<p>Use PID via jps to check the PID of the currently running Java application process.</p>

<p>如果JDK版本是1.6或以上,可以在MS Windows上使用jstack.</p>

<p>使用jps来产看系统上正运行的java进程的PID.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ jps -v
</span><span class='line'>25780 RemoteTestRunner -Dfile.encoding=UTF-8
</span><span class='line'>25590 sub.rmi.registry.RegistryImpl 2999 -Dapplication.home=/home1/user/java/jdk.1.6.0_24 -Xms8m
</span><span class='line'>26300 sun.tools.jps.Jps -mlvV -Dapplication.home=/home1/user/java/jdk.1.6.0_24 -Xms8m</span></code></pre></td></tr></table></div></figure>


<p>Use the extracted PID as the parameter of jstack to obtain a thread dump.</p>

<p>把pid作为参数传给jstack,以获取该pid对应java进程的线程转储.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ jstack -f 5824</span></code></pre></td></tr></table></div></figure>


<h4>A Thread Dump Using jVisualVM</h4>

<h4>使用jVisualVM</h4>

<p>Generate a thread dump by using a program such as jVisualVM.</p>

<p>jVisualVM是JDK提供的可视化工具.</p>

<p><img src="http://yangtao309.github.io/images/u404847178_13c476d1fd4g86_blog.png" alt="Alt text" /></p>

<p>Figure 2:  A Thread Dump Using visualvm.</p>

<p>The task on the left indicates the list of currently running processes. Click on the process for which you want the information, and select the thread tab to check the thread information in real time. Click the Thread Dump button on the top right corner to get the thread dump file.</p>

<p>左侧列举了正在运行的java进程.单击想要分析的进程,选择thread选项卡,可以看到实时信息.单击右上角的Thread Dump按钮生成线程转储文件.</p>

<h4>Generating in a Linux Terminal</h4>

<p>Obtain the process pid by using ps -ef command to check the pid of the currently running Java process.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ ps - ef | grep java
</span><span class='line'>user      2477          1    0 Dec23 ?         00:10:45 ...
</span><span class='line'>user    25780 25361   0 15:02 pts/3    00:00:02 ./jstatd -J -Djava.security.policy=jstatd.all.policy -p 2999
</span><span class='line'>user    26335 25361   0 15:49 pts/3    00:00:00 grep java</span></code></pre></td></tr></table></div></figure>


<p>Use the extracted pid as the parameter of kill –SIGQUIT(3) to obtain a thread dump.</p>

<h4>Thread Information from the Thread Dump File</h4>

<h4>线程转储文件包含的线程信息</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"pool-1-thread-13" prio=6 tid=0x000000000729a000 nid=0x2fb4 runnable [0x0000000007f0f000] java.lang.Thread.State: RUNNABLE
</span><span class='line'>at java.net.SocketInputStream.socketRead0(Native Method)
</span><span class='line'>at java.net.SocketInputStream.read(SocketInputStream.java:129)
</span><span class='line'>at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)
</span><span class='line'>at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)
</span><span class='line'>at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)
</span><span class='line'> 
</span><span class='line'>- locked &lt;0x0000000780b7e688&gt; (a java.io.InputStreamReader)
</span><span class='line'> 
</span><span class='line'>at java.io.InputStreamReader.read(InputStreamReader.java:167)
</span><span class='line'>at java.io.BufferedReader.fill(BufferedReader.java:136)
</span><span class='line'>at java.io.BufferedReader.readLine(BufferedReader.java:299)
</span><span class='line'> 
</span><span class='line'>- locked &lt;0x0000000780b7e688&gt; (a java.io.InputStreamReader)
</span><span class='line'> 
</span><span class='line'>at java.io.BufferedReader.readLine(BufferedReader.java:362)
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Thread name: When using Java.lang.Thread class to generate a thread, the thread will be named Thread-(Number), whereas when using java.util.concurrent.ThreadFactory class, it will be named pool-(number)-thread-(number).</li>
<li>Priority: Represents the priority of the threads.</li>
<li>Thread ID: Represents the unique ID for the threads. (Some useful information, including the CPU usage or memory usage of the thread, can be obtained by using thread ID.)</li>
<li>Thread status: Represents the status of the threads.</li>
<li><p>Thread callstack: Represents the call stack information of the threads.</p></li>
<li><p>Thread name 线程名: 使用 Java.lang.Thread类去创建线程时,线程的命名方式为Thread-(序号);当使用java.util.concurrent.ThreadFactory类去创建线程时,线程的命名方式为pool-(序号)-thread-(序号).</p></li>
<li>Priority 优先级: 表示线程的优先级.</li>
<li>Thread ID 线程ID: 线程的ID是唯一的(一些有用的信息,比如线程的CPU使用率或者内存使用率,可以通过线程ID找到).</li>
<li>Thread status 线程状态: 表示线程的状态.</li>
<li>Thread callstack 线程调用栈: 表示线程的调用栈信息.</li>
</ul>


<h3>Thread Dump Patterns by Type</h3>

<h3>线程转储的类型布局</h3>

<h4>When Unable to Obtain a Lock (BLOCKED)</h4>

<h4>无法获得锁的时候</h4>

<p>This is when the overall performance of the application slows down because a thread is occupying the lock and prevents other threads from obtaining it. In the following example, BLOCKED_TEST pool-1-thread-1 thread is running with <0x0000000780a000b0> lock, while BLOCKED_TEST pool-1-thread-2 and BLOCKED_TEST pool-1-thread-3 threads are waiting to obtain <0x0000000780a000b0> lock.</p>

<p>此时整个应用的性能下降了,因为一个线程持有了锁而不肯释放,导致其它线程无法获得锁.在下面的例子里,线程BLOCKED_TEST pool-1-thread-1 获得了锁<0x0000000780a000b0>并且正在运行,此时线程 BLOCKED_TEST pool-1-thread-2 和线程 BLOCKED_TEST pool-1-thread-3 在等待锁<0x0000000780a000b0>.</p>

<p><img src="http://yangtao309.github.io/images/u404847178_13c476deae9g85_blog.png" alt="Alt text" /></p>

<p>Figure 3: A thread blocking other threads.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"BLOCKED_TEST pool-1-thread-1" prio=6 tid=0x0000000006904800 nid=0x28f4 runnable [0x000000000785f000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at java.io.FileOutputStream.writeBytes(Native Method)
</span><span class='line'>    at java.io.FileOutputStream.write(FileOutputStream.java:282)
</span><span class='line'>    at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)
</span><span class='line'>    at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:123)
</span><span class='line'>    - locked &lt;0x0000000780a31778&gt; (a java.io.BufferedOutputStream)
</span><span class='line'>    at java.io.PrintStream.write(PrintStream.java:432)
</span><span class='line'>    - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)
</span><span class='line'>    at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:202)
</span><span class='line'>    at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:272)
</span><span class='line'>    at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:85)
</span><span class='line'>    - locked &lt;0x0000000780a040c0&gt; (a java.io.OutputStreamWriter)
</span><span class='line'>    at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:168)
</span><span class='line'>    at java.io.PrintStream.newLine(PrintStream.java:496)
</span><span class='line'>    - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)
</span><span class='line'>    at java.io.PrintStream.println(PrintStream.java:687)
</span><span class='line'>    - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:44)
</span><span class='line'>    - locked &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState$1.run(ThreadBlockedState.java:7)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - &lt;0x0000000780a31758&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
</span><span class='line'>
</span><span class='line'>"BLOCKED_TEST pool-1-thread-2" prio=6 tid=0x0000000007673800 nid=0x260c waiting for monitor entry [0x0000000008abf000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:43)
</span><span class='line'>    - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState$2.run(ThreadBlockedState.java:26)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - &lt;0x0000000780b0c6a0&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
</span><span class='line'>
</span><span class='line'>"BLOCKED_TEST pool-1-thread-3" prio=6 tid=0x00000000074f5800 nid=0x1994 waiting for monitor entry [0x0000000008bbf000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:42)
</span><span class='line'>    - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadBlockedState$3.run(ThreadBlockedState.java:34)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - &lt;0x0000000780b0e1b8&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span></code></pre></td></tr></table></div></figure>


<h4>When in Deadlock Status</h4>

<h4>死锁的时候</h4>

<p>This is when thread A needs to obtain thread B&rsquo;s lock to continue its task, while thread B needs to obtain thread A&rsquo;s lock to continue its task. In the thread dump, you can see that DEADLOCK_TEST-1 thread has 0x00000007d58f5e48 lock, and is trying to obtain 0x00000007d58f5e60 lock. You can also see that DEADLOCK_TEST-2 thread has 0x00000007d58f5e60 lock, and is trying to obtain 0x00000007d58f5e78 lock. Also, DEADLOCK_TEST-3 thread has 0x00000007d58f5e78 lock, and is trying to obtain 0x00000007d58f5e48 lock. As you can see, each thread is waiting to obtain another thread&rsquo;s lock, and this status will not change until one thread discards its lock.</p>

<p>线程A需要获取线程B的锁,而且B的锁需要获取A的锁.在线程转储文件里,你可以看到 线程DEADLOCK_TEST-1 持有锁0x00000007d58f5e48,并试图获取 锁0x00000007d58f5e60. 你还能看到 线程DEADLOCK_TEST-2 持有 锁0x00000007d58f5e60, 并试图获取 锁0x00000007d58f5e78. 同样, 线程DEADLOCK_TEST-3 持有 锁0x00000007d58f5e78, 并试图获取 锁0x00000007d58f5e48. 和你看到的一样, 每个线程都在等着获取其它线程的锁, 这个状态保持不变, 除非有个线程放弃了它的锁.</p>

<p><img src="http://yangtao309.github.io/images/when-in-deadlock-status.png" alt="Alt text" /></p>

<p>Figure 4: Threads in a Deadlock status.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"DEADLOCK_TEST-1" daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting for monitor entry [0x000000000805f000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)
</span><span class='line'>    - waiting to lock &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)
</span><span class='line'>    - locked &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - None
</span><span class='line'>
</span><span class='line'>"DEADLOCK_TEST-2" daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting for monitor entry [0x000000000815f000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)
</span><span class='line'>    - waiting to lock &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)
</span><span class='line'>    - locked &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>    - None
</span><span class='line'>
</span><span class='line'>"DEADLOCK_TEST-3" daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting for monitor entry [0x000000000825f000]
</span><span class='line'>   java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)
</span><span class='line'>    - waiting to lock &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)
</span><span class='line'>    - locked &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)
</span><span class='line'>
</span><span class='line'>   Locked ownable synchronizers:
</span><span class='line'>                - None</span></code></pre></td></tr></table></div></figure>


<h4>When Continuously Waiting to Receive Messages from a Remote Server</h4>

<h4>持续等待接收远程服务器数据的时候</h4>

<p>The thread appears to be normal, since its state keeps showing as RUNNABLE. However, when you align the thread dumps chronologically, you can see that socketReadThread thread is waiting infinitely to read the socket.</p>

<p>因为线程的状态一直是 RUNNABLE ,所以它看起来很正常. 然而, 当你把多个线程转出文件按时间顺序排列, 你可以看到线程 socketReadThread 在无限等待读取socket.</p>

<p><img src="http://yangtao309.github.io/images/when-continuosly-waiting-to-receive-message-from-remote-server.png" alt="Alt text" /></p>

<p>Figure 5: Continuous Waiting Status.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"socketReadThread" prio=6 tid=0x0000000006a0d800 nid=0x1b40 runnable [0x00000000089ef000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at java.net.SocketInputStream.socketRead0(Native Method)
</span><span class='line'>    at java.net.SocketInputStream.read(SocketInputStream.java:129)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)
</span><span class='line'>    - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.read0(StreamDecoder.java:107)
</span><span class='line'>    - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)
</span><span class='line'>    at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:93)
</span><span class='line'>    at java.io.InputStreamReader.read(InputStreamReader.java:151)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadSocketReadState$1.run(ThreadSocketReadState.java:27)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)</span></code></pre></td></tr></table></div></figure>


<h4>When Waiting</h4>

<h4>等待的时候</h4>

<p>The thread is maintaining WAIT status. In the thread dump, IoWaitThread thread keeps waiting to receive a message from LinkedBlockingQueue. If there continues to be no message for LinkedBlockingQueue, then the thread status will not change.</p>

<p>线程处于 WAIT 状态. 线程转储文件里, 线程IoWaitThread 一直等待来自 LinkedBlockingQueue 的消息. 如果 LinkedBlockingQueue 没有消息, 那么线程的状态就不会改变.</p>

<p><img src="http://yangtao309.github.io/images/when-waiting.png" alt="Alt text" /></p>

<p>Figure 6: Waiting status.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"IoWaitThread" prio=6 tid=0x0000000007334800 nid=0x2b3c waiting on condition [0x000000000893f000]
</span><span class='line'>   java.lang.Thread.State: WAITING (parking)
</span><span class='line'>    at sun.misc.Unsafe.park(Native Method)
</span><span class='line'>    - parking to wait for  &lt;0x00000007d5c45850&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
</span><span class='line'>    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)
</span><span class='line'>    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)
</span><span class='line'>    at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:440)
</span><span class='line'>    at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:629)
</span><span class='line'>    at com.nbp.theplatform.threaddump.ThreadIoWaitState$IoWaitHandler2.run(ThreadIoWaitState.java:89)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)</span></code></pre></td></tr></table></div></figure>


<h4>When Thread Resources Cannot be Organized Normally</h4>

<h4>线程资源管理失控的时候</h4>

<p>Unnecessary threads will pile up when thread resources cannot be organized normally. If this occurs, it is recommended to monitor the thread organization process or check the conditions for thread termination.</p>

<p>如果不能有效地管理线程资源,那么一些不必要的线程就因为没有被销毁而越来越多. 发生这种状况的时候, 应该检查负责线程管理的线程,或者检查线程停止条件.</p>

<p><img src="http://yangtao309.github.io/images/when-thread-resources-cannot-be-organized-normally.png" alt="Alt text" /></p>

<p>Figure 7: Unorganized Threads.</p>

<h3>How to Solve Problems by Using Thread Dump</h3>

<h3>如何用线程转储解决问题</h3>

<h4>Example 1: When the CPU Usage is Abnormally High</h4>

<h4>例 1: CPU使用率过高</h4>

<ol>
<li><p>Extract the thread that has the highest CPU usage.</p>

<p> 找出哪个线程占用了最多的CPU资源.</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[user@linux ~]$ ps -mo pid.lwp.stime.time.cpu -C java
</span><span class='line'>      PID         LWP          STIME          TIME               %CPU
</span><span class='line'>     10029          -         Dec07          00:02:02           99.5
</span><span class='line'>         -       10039        Dec07          00:00:00            0.1
</span><span class='line'>         -       10040        Dec07          00:00:00           95.5</span></code></pre></td></tr></table></div></figure>


<p>From the application, find out which thread is using the CPU the most.</p>

<p>Acquire the Light Weight Process (LWP) that uses the CPU the most and convert its unique number (10039) into a hexadecimal number (0x2737).</p>

<p>找出应用里最占用CPU的那个线程,并获得它的轻量进程 Light Weight Process (LWP). 把这个唯一的LWP数字 (10039) 转成十六进制 (0x2737).</p>

<ol>
<li><p>After acquiring the thread dump, check the thread&rsquo;s action.</p>

<p> 得到线程转储文件之后, 检查线程执行的动作.</p></li>
</ol>


<p>Extract the thread dump of an application with a PID of 10029, then find the thread with an nid of 0x2737.</p>

<p>把PID为10029的应用进行线程转储, 然后找到nid为 0x2737 的线程.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"NioProcessor-2" prio=10 tid=0x0a8d2800 nid=0x2737 runnable [0x49aa5000] java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
</span><span class='line'>    at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:210)
</span><span class='line'>    at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:65)
</span><span class='line'>    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:69)
</span><span class='line'>    - locked &lt;0x74c52678&gt; (a sun.nio.ch.Util$1)
</span><span class='line'>    - locked &lt;0x74c52668&gt; (a java.util.Collections$UnmodifiableSet)
</span><span class='line'>    - locked &lt;0x74c501b0&gt; (a sun.nio.ch.EPollSelectorImpl)
</span><span class='line'>    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:80)
</span><span class='line'>    at external.org.apache.mina.transport.socket.nio.NioProcessor.select(NioProcessor.java:65)
</span><span class='line'>    at external.org.apache.mina.common.AbstractPollingIoProcessor$Worker.run(AbstractPollingIoProcessor.java:708)
</span><span class='line'>    at external.org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>    at java.lang.Thread.run(Thread.java:662)</span></code></pre></td></tr></table></div></figure>


<p>Extract thread dumps several times every hour, and check the status change of the threads to determine the problem.</p>

<p>按一小时的时间间隔获取多个线程转储文件, 查看线程状态的变化来定位问题.</p>

<h4>Example 2: When the Processing Performance is Abnormally Slow</h4>

<h4>例 2: 应用的效率过低</h4>

<p>After acquiring thread dumps several times, find the list of threads with BLOCKED status.</p>

<p>获取多个线程转储文件之后, 找到状态为 BLOCKED 的所有线程.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> "DB-Processor-13" daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f000]
</span><span class='line'>java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at beans.ConnectionPool.getConnection(ConnectionPool.java:102)
</span><span class='line'>    - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)
</span><span class='line'>    at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)
</span><span class='line'>    at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)
</span><span class='line'>
</span><span class='line'>"DB-Processor-14" daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f020]
</span><span class='line'>java.lang.Thread.State: BLOCKED (on object monitor)
</span><span class='line'>    at beans.ConnectionPool.getConnection(ConnectionPool.java:102)
</span><span class='line'>    - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)
</span><span class='line'>    at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)
</span><span class='line'>    at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)
</span><span class='line'>
</span><span class='line'>"" "DB-Processor-3"" daemon prio=5 tid=0x00928248 nid=0x8b waiting for monitor entry [0x000000000825d080]
</span><span class='line'>java.lang.Thread.State: RUNNABLE
</span><span class='line'>    at oracle.jdbc.driver.OracleConnection.isClosed(OracleConnection.java:570)
</span><span class='line'>    - waiting to lock &lt;0xe03ba2e0&gt; (a oracle.jdbc.driver.OracleConnection)
</span><span class='line'>    at beans.ConnectionPool.getConnection(ConnectionPool.java:112)
</span><span class='line'>    - locked &lt;0xe0386580&gt; (a java.util.Vector)
</span><span class='line'>    - locked &lt;0xe0375410&gt; (a beans.ConnectionPool)
</span><span class='line'>    at beans.cus.Cue_1700c.GetNationList(Cue_1700c.java:66)
</span><span class='line'>    at org.apache.jsp.cue_1700c_jsp._jspService(cue_1700c_jsp.java:12)</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Acquire the list of threads with BLOCKED status after getting the thread dumps several times.</p>

<p> If the threads are BLOCKED, extract the threads related to the lock that the threads are trying to obtain.</p>

<p>Through the thread dump, you can confirm that the thread status stays BLOCKED because <0xe0375410> lock could not be obtained. This problem can be solved by analyzing stack trace from the thread currently holding the lock.</p>

<p>There are two reasons why the above pattern frequently appears in applications using DBMS. The first reason is inadequate configurations. Despite the fact that the threads are still working, they cannot show their best performance because the configurations for DBCP and the like are not adequate. If you extract thread dumps multiple times and compare them, you will often see that some of the threads that were BLOCKED previously are in a different state.</p>

<p>The second reason is the abnormal connection. When the connection with DBMS stays abnormal, the threads wait until the time is out. In this case, even after extracting the thread dumps several times and comparing them, you will see that the threads related to DBMS are still in a BLOCKED state. By adequately changing the values, such as the timeout value, you can shorten the time in which the problem occurs.</p>

<p>如果线程处于 BLOCKED 状态, 首先查找阻塞它的锁, 然后把和这个锁有关的线程找出来. 从上面的转储文件里, 你可以看到处于 BLOCKED 状态的线程, 她想获得锁 <0xe0375410>. 这个问题可以通过分析持有锁的线程的调用栈来解决. 使用DBMS的应用会频繁地出现上述问题, 原因有两个. 一是配置不完善. 尽管线程可以运行, 但是类似DBCP等选项没有被正确配置,所以达不到最高的效率. 如果获取多个线程转储文件并比较它们, 你会发现处于 BLOCKED 状态的线程之前是其它状态. 二是连接异常. 如果与DBMS的连接异常, 线程会一直等到超时. 这种情况下, 导出并比较多个转储文件, 你会发现和DBMS有关的线程仍然处于 BLOCKED 状态. 通过多次调整参数, 比如超时时间, 你可以缩短上述问题发生的时间.</p>

<h3>Coding for Easy Thread Dump</h3>

<h3>有利于线程转储的编码方式</h3>

<h4>Naming Threads</h4>

<h4>给线程命名</h4>

<p>When a thread is created using java.lang.Thread object, the thread will be named Thread-(Number). When a thread is created using java.util.concurrent.DefaultThreadFactory object, the thread will be named pool-(Number)-thread-(Number). When analyzing tens to thousands of threads for an application, if all the threads still have their default names, analyzing them becomes very difficult, because it is difficult to distinguish the threads to be analyzed.</p>

<p>使用java.lang.Thread 创建线程时, 线程被命名为 Thread-(序号). 使用java.util.concurrent.DefaultThreadFactory 创建线程, 线程被命名为 pool-(序号)-thread-(序号). 如果应用有成百上千的线程, 这些线程都使用默认的命名, 分析这些线程就变得困难, 因为区分这些线程不是一件容易的事.</p>

<p>Therefore, you are recommended to develop the habit of naming the threads whenever a new thread is created.</p>

<p>所以,要养成给线程命名的好习惯.</p>

<p>When you create a thread using java.lang.Thread, you can give the thread a custom name by using the creator parameter.</p>

<p>使用 java.lang.Thread时, 通过构造函数给线程一个定制的名字.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Thread(Runnable target, String name);
</span><span class='line'>public Thread(ThreadGroup group, String name);
</span><span class='line'>public Thread(ThreadGroup group, Runnable target, String name);
</span><span class='line'>public Thread(ThreadGroup group, Runnable target, String name, long stackSize);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>When you create a thread using java.util.concurrent.ThreadFactory, you can name it by generating your own ThreadFactory. If you do not need special functionalities, then you can use MyThreadFactory as described below:</p>

<p>使用 java.util.concurrent.ThreadFactory时, 可以自己实现一个ThreadFactory. 如果没有特殊的需求, 下面的例子就足够了.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import java.util.concurrent.ConcurrentHashMap;
</span><span class='line'>import java.util.concurrent.ThreadFactory;
</span><span class='line'>import java.util.concurrent.atomic.AtomicInteger;
</span><span class='line'> 
</span><span class='line'>public class MyThreadFactory implements ThreadFactory {
</span><span class='line'>  private static final ConcurrentHashMap&lt;String, AtomicInteger&gt; POOL_NUMBER =
</span><span class='line'>                                                       new ConcurrentHashMap&lt;String, AtomicInteger&gt;();
</span><span class='line'>  private final ThreadGroup group;
</span><span class='line'>  private final AtomicInteger threadNumber = new AtomicInteger(1);
</span><span class='line'>  private final String namePrefix;
</span><span class='line'>  
</span><span class='line'>  public MyThreadFactory(String threadPoolName) {
</span><span class='line'>       
</span><span class='line'>      if (threadPoolName == null) {
</span><span class='line'>          throw new NullPointerException("threadPoolName");
</span><span class='line'>      }
</span><span class='line'>        
</span><span class='line'>      POOL_NUMBER.putIfAbsent(threadPoolName, new AtomicInteger());
</span><span class='line'>       
</span><span class='line'>      SecurityManager securityManager = System.getSecurityManager();
</span><span class='line'>      group = (securityManager != null) ? securityManager.getThreadGroup() :
</span><span class='line'>                                                    Thread.currentThread().getThreadGroup();
</span><span class='line'>       
</span><span class='line'>      AtomicInteger poolCount = POOL_NUMBER.get(threadPoolName);
</span><span class='line'> 
</span><span class='line'>      if (poolCount == null) {
</span><span class='line'>            namePrefix = threadPoolName + " pool-00-thread-";
</span><span class='line'>      } else {
</span><span class='line'>            namePrefix = threadPoolName + " pool-" + poolCount.getAndIncrement() + "-thread-";
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  public Thread newThread(Runnable runnable) {
</span><span class='line'>      Thread thread = new Thread(group, runnable, namePrefix + threadNumber.getAndIncrement(), 0);
</span><span class='line'> 
</span><span class='line'>      if (thread.isDaemon()) {
</span><span class='line'>            thread.setDaemon(false);
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>      if (thread.getPriority() != Thread.NORM_PRIORITY) {
</span><span class='line'>            thread.setPriority(Thread.NORM_PRIORITY);
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>      return thread;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Obtaining More Detailed Information by Using MBean</h4>

<h4>通过MBean获得更详细的信息</h4>

<p>You can obtain ThreadInfo objects using MBean. You can also obtain more information that would be difficult to acquire via thread dumps, by using ThreadInfo.</p>

<p>你可以使用MBean获得ThreadInfo对象. 你也可以使用ThreadInfo来获得一些信息, 而线程转储的方式很难获取这些信息.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
</span><span class='line'>long[] threadIds = mxBean.getAllThreadIds();
</span><span class='line'>ThreadInfo[] threadInfos = mxBean.getThreadInfo(threadIds);
</span><span class='line'> 
</span><span class='line'>for (ThreadInfo threadInfo : threadInfos) {
</span><span class='line'>  System.out.println(threadInfo.getThreadName());
</span><span class='line'>  System.out.println(threadInfo.getBlockedCount());
</span><span class='line'>  System.out.println(threadInfo.getBlockedTime());
</span><span class='line'>  System.out.println(threadInfo.getWaitedCount());
</span><span class='line'>  System.out.println(threadInfo.getWaitedTime());
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>You can acquire the amount of time that the threads WAITed or were BLOCKED by using the method in ThreadInfo, and by using this you can also obtain the list of threads that have been inactive for an abnormally long period of time.</p>

<p>你可以方便地得到线程处于 WAIT 和 BLOCKED 状态的时间, 由此你可以获得那些长期处于不活动状态的线程列表.</p>

<h3>In Conclusion</h3>

<h3>结论</h3>

<p>In this article I was concerned that for developers with a lot of experience in multi-thread programming, this material may be common knowledge, whereas for less experienced developers, I felt that I was skipping straight to thread dumps, without providing enough background information about the thread activities. This was because of my lack of knowledge, as I was not able to explain the thread activities in a clear yet concise manner. I sincerely hope that this article will prove helpful for many developers.</p>

<p>这篇文章总结了处理多线程的常识性的经验, 对这方面有很多经验的人来说可能帮助不大. 对新人来说, 我感觉我在开门见山地讲线程转储, 而略过了线程活动的背景知识. 这是因为我缺少这方面的经验, 不能简单扼要地进行阐述. 我真诚地希望这篇文章能够帮助更多的人.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJs的初次体验]]></title>
    <link href="http://yangtao309.github.io/blog/2013/08/14/angularjs-1th-taste/"/>
    <updated>2013-08-14T23:41:00+08:00</updated>
    <id>http://yangtao309.github.io/blog/2013/08/14/angularjs-1th-taste</id>
    <content type="html"><![CDATA[<h6>用angularjs来实现个啥东西？</h6>

<ul>
<li>右边为列表的展示</li>
<li>左边search栏为输入筛选的字段，对应的列表展示筛选的结果。</li>
<li>左边Sort by 栏为选择排序值，对应的列表展示排序结果。</li>
<li>Reverse Searchd的值是search input框值得逆序。（可以通过穿件directive或者filter）。</li>
<li>点击莫个链接，改变hash值来切换模块，展现不同的页面。（利用n-view或者ng-include指令）。</li>
</ul>


<h6>需要用到的指令以及筛选filter</h6>

<ol>
<li>ng-app</li>
<li>ng-repeat</li>
<li>ng-model</li>
<li>ng-view</li>
<li>filter</li>
<li>orderBy</li>
<li>自定义指令ngreverse</li>
</ol>


<h6>代码示例</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>City:<span class="p">&lt;</span><span class="n">input</span> ng-model<span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="n">/&gt;</span>
</span><span class='line'>City reverse:<span class="p">&lt;</span><span class="n">span</span> ngreverse<span class="o">=</span><span class="s2">&quot;city&quot;</span> style<span class="o">=</span><span class="s2">&quot;color:red;&quot;</span>&gt;&lt;<span class="n">/span&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>appModule.directive(<span class="s1">&#39;ngreverse&#39;</span><span class="p">,</span> function() {
</span><span class='line'>      return function(scope<span class="p">,</span> element<span class="p">,</span> attrs){
</span><span class='line'>          scope.$watch(attrs.ngreverse<span class="p">,</span> function(value) {
</span><span class='line'>              value <span class="o">=</span> value <span class="o">==</span> undefined ? <span class="s2">&quot;&quot;</span> : value;
</span><span class='line'>              element.text(reverse(value));
</span><span class='line'>          });
</span><span class='line'>      };
</span><span class='line'>  });
</span></code></pre></td></tr></table></div></figure>


<h6>代码实现细节</h6>

<ul>
<li>$routeProvider</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>var appModule <span class="o">=</span> angular.module(<span class="s1">&#39;phonecat&#39;</span><span class="p">,</span> []);
</span><span class='line'>appModule.config(
</span><span class='line'>  [<span class="s1">&#39;$routeProvider&#39;</span><span class="p">,</span> function($routeProvider) {
</span><span class='line'>      $routeProvider.when(<span class="s1">&#39;/&#39;</span><span class="p">,</span> {
</span><span class='line'>          templateUrl: <span class="s1">&#39;phone-list.html&#39;</span><span class="p">,</span>
</span><span class='line'>          controller: PhoneListCtrl
</span><span class='line'>      }).when(<span class="s1">&#39;/:phoneId/:phoneAge&#39;</span><span class="p">,</span> {
</span><span class='line'>          templateUrl: <span class="s1">&#39;phone-detail.html&#39;</span><span class="p">,</span>
</span><span class='line'>          controller: PhoneDetailCtrl
</span><span class='line'>      }).otherwise({redirectTo: <span class="s1">&#39;/&#39;</span>});
</span><span class='line'>  }]);
</span></code></pre></td></tr></table></div></figure>


<h6>实现效果</h6>

<p><img src="http://yangtao309.github.io/images/qq-20130824094417.jpg" width="650" height="350" title="image" alt="images"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven-release-plugin 实践]]></title>
    <link href="http://yangtao309.github.io/blog/2013/07/20/maven-release-plugin-best-practice/"/>
    <updated>2013-07-20T08:50:00+08:00</updated>
    <id>http://yangtao309.github.io/blog/2013/07/20/maven-release-plugin-best-practice</id>
    <content type="html"><![CDATA[<h4>maven-release-plugin简介</h4>

<p>该插件是maven自带的用于发布项目之用，比如我们用SCM的svn来管理源代码，一般会分为trunk/branches/tags三个目录。
trunk对应主线开发，一般对应的是SNAPSHOT版本，而branches可以是从trunk copy to的一个修复的小版本，也可以是从
tags copy to的一个要修复的版本，同样对应的是SNAPSHOT版本。仅有tags下面的项目的版本号定义为release。
至于maven下的release与snapshot的区别，不清楚的同学可以猛击:<a href="http://www.mzone.cc/article/277.html">http://www.mzone.cc/article/277.html</a></p>

<p>官网地址: <a href="http://maven.apache.org/maven-release/maven-release-plugin/">http://maven.apache.org/maven-release/maven-release-plugin/</a></p>

<h4>如何用好maven-release-plugin</h4>

<p>在实际开发中，为了方便修复bug，以及准备测试程序包。按照规范流程都需要将开发程序打包成tag，然后将程序发布出去。
那么我就经常需要从 1.0-SNAPSHOT到1.0到1.1-SNAPSHOT 这样的操作。对于项目个数比较少的情况，手动修改也未尝不可。
对于比较复杂的系统，分成了大量的服务，业务模块的，少则7，8个多者20+个。笔者在实际应用中的就是包含有20多个工程。
在没有应用release插件的时候，基本上负责发布的同学很头疼，也想办法用shell脚本去改pom的版本号。但是还是稍显麻烦。</p>

<h4>1.0-SNAPSHOT到1.0到1.1-SNAPSHOT</h4>

<p>SNAPSHOT是快照的意思，项目到一个阶段后，就需要发布一个正式的版本（release版本）。一次正式的发布需要这样一些工作：</p>

<pre><code>在trunk中，更新pom版本从1.0-SNAPSHOT到1.0
对1.0打一个svn tag
针对tag进行mvn deploy，发布正式版本
更新trunk从1.0到1.1-SNAPSHOT
</code></pre>

<h4>SCM</h4>

<p>首先我们需要在POM中加入scm信息，这样Maven才能够替你完成svn操作，示例配置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="p">&lt;</span><span class="n">scm</span>&gt;
</span><span class='line'>  <span class="p">&lt;</span><span class="n">connection</span><span class="p">&gt;</span><span class="n">scm</span><span class="nl">:svn:http</span>:<span class="n">//svn地址前缀部分/myapp/trunk/&lt;/connection&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">developerConnection</span><span class="p">&gt;</span><span class="n">scm</span><span class="nl">:svn:http</span>:<span class="n">//svn地址前缀部分/myapp/trunk/&lt;/developerConnection&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">url</span><span class="p">&gt;</span><span class="n">scm</span><span class="nl">:svn:http</span>:<span class="n">//svn地址前缀部分/myapp/trunk/&lt;/url&gt;</span>
</span><span class='line'>&lt;<span class="n">/scm&gt;</span>
</span><span class='line'>这样的配置是对应trunk下pom的配置，各个branches和tags都不一样，需要是其对于的svn地址
</span></code></pre></td></tr></table></div></figure>


<h4>maven-release-plugin 应用配置</h4>

<p>紧接着，我们需要配置maven-release-plugin，这个插件会帮助我们升级pom版本，提交，打tag，然后再升级版本，再提交，等等。配置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="p">&lt;</span><span class="n">plugin</span>&gt;
</span><span class='line'>  <span class="p">&lt;</span><span class="n">groupId</span><span class="p">&gt;</span><span class="n">org</span>.apache.maven.plugins&lt;<span class="n">/groupId&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">artifactId</span><span class="p">&gt;</span><span class="n">maven</span>-release-plugin&lt;<span class="n">/artifactId&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">version</span><span class="p">&gt;</span><span class="n">2</span>.<span class="m">4</span>.<span class="m">1</span>&lt;<span class="n">/version&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">configuration</span>&gt;
</span><span class='line'>      &lt;!-- mvn release:branch -DbranchName<span class="o">=</span>xxx -DupdateBranchVersions<span class="o">=</span>true
</span><span class='line'>                      -DupdateWorkingCopyVersion<span class="o">=</span>false --&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">branchBase</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//svn地址前缀部分/myapp/branches&lt;/branchBase&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">arguments</span>&gt;
</span><span class='line'>          -Dmaven.test.skip<span class="o">=</span>true
</span><span class='line'>      &lt;<span class="n">/arguments&gt;</span>
</span><span class='line'>
</span><span class='line'>      &lt;!-- mvn release:perform -DautoVersionSubmodules<span class="o">=</span>true -DupdateWorkingCopyVersion<span class="o">=</span>false --&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">tagBase</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//svn地址前缀部分/myapp/tags&lt;/tagBase&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">waitBeforeTagging</span><span class="p">&gt;</span><span class="n">10</span>&lt;<span class="n">/waitBeforeTagging&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">username</span>&gt;${svn.username}&lt;<span class="n">/username&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">password</span>&gt;${svn.password}&lt;<span class="n">/password&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">mavenHome</span>&gt;${svn.maven.home}&lt;<span class="n">/mavenHome&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">scmCommentPrefix</span><span class="p">&gt;</span>
</span><span class='line'><span class="n">issue</span><span class="nl">:maven</span>-release-plugin
</span><span class='line'>msg:excute maven-release-plugin
</span><span class='line'>      &lt;<span class="n">/scmCommentPrefix&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">autoVersionSubmodules</span><span class="p">&gt;</span><span class="n">true</span>&lt;<span class="n">/autoVersionSubmodules&gt;</span>
</span><span class='line'>  &lt;<span class="n">/configuration&gt;</span>
</span><span class='line'>&lt;<span class="n">/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的配置可以知道，需要配置svn提交的用户名和密码以及svn安装目录，还有就是svn提交的注释(可选)。
另外在release插件打包发布到似有远程仓库的部分需要配置:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="p">&lt;</span><span class="n">distributionManagement</span>&gt;
</span><span class='line'>  <span class="p">&lt;</span><span class="n">repository</span>&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">id</span><span class="p">&gt;</span><span class="n">nexus</span>&lt;<span class="n">/id&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">name</span><span class="p">&gt;</span><span class="n">Nexus</span>&lt;<span class="n">/name&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">url</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//ci仓库域名/nexus/content/repositories/releases&lt;/url&gt;</span>
</span><span class='line'>  &lt;<span class="n">/repository&gt;</span>
</span><span class='line'>  <span class="p">&lt;</span><span class="n">snapshotRepository</span>&gt;
</span><span class='line'>      <span class="p">&lt;</span><span class="n">id</span><span class="p">&gt;</span><span class="n">nexus</span>&lt;<span class="n">/id&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">name</span><span class="p">&gt;</span><span class="n">Nexus</span>&lt;<span class="n">/name&gt;</span>
</span><span class='line'>      <span class="p">&lt;</span><span class="n">url</span><span class="p">&gt;</span><span class="n">http</span>:<span class="n">//ci仓库域名/nexus/content/repositories/snapshots&lt;/url&gt;</span>
</span><span class='line'>  &lt;<span class="n">/snapshotRepository&gt;</span>
</span><span class='line'>&lt;<span class="n">/distributionManagement&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>执行、操作 Action</h4>

<h6>mvn release:prepare</h6>

<blockquote><p>执行过程中，你会遇到这样的提示：</p>

<p>What is the release version for &ldquo;Unnamed - org.myorg:myapp:jar:1.0-SNAPSHOT&rdquo;? (org.myorg:myapp) 1.0: :</p>

<p>——“你想将1.0-SNAPSHOT发布为什么版本？默认是1.0。”我要的就是1.0，直接回车。</p>

<p>What is SCM release tag or label for &ldquo;Unnamed - org.myorg:myapp:jar:1.0-SNAPSHOT&rdquo;? (org.myorg:myapp) myapp-1.0: :</p>

<p>——“发布的tag标签名称是什么？默认为myapp-1.0。”我还是要默认值，直接回车。</p>

<p>What is the new development version for &ldquo;Unnamed - org.myorg:myapp:jar:1.0-SNAPSHOT&rdquo;? (org.myorg:myapp) 1.1-SNAPSHOT: :</p>

<p>——“主干上新的版本是什么？默认为1.1-SNAPSHOT。”哈，release插件会自动帮我更新版本到1.1-SNAPSHOT，很好，直接回车。</p>

<p>然后屏幕刷阿刷，maven在build我们的项目，并进行了一些svn操作，你可以仔细查看下日志。</p>

<p>那么结果是什么呢？你可以浏览下svn仓库：</p>

<p>   我们多了一个tag：<a href="https://svn-address.com/myapp/tags/myapp-1.0/">https://svn-address.com/myapp/tags/myapp-1.0/</a>  这就是需要发布的版本1.0。
   再看看trunk中的POM，其版本自动升级成了1.1-SNAPSHOT。</p>

<p>这不正是我们想要的么？等等，好像缺了点什么，对了，1.0还没有发布到仓库中呢。</p>

<p>再一次屏住呼吸，执行：</p></blockquote>

<h6>mvn release:perform</h6>

<blockquote><p>maven-release-plugin会自动帮我们签出刚才打的tag，然后打包，分发到远程Maven仓库中，至此，整个版本的升级，打标签，发布等工作全部完成。我们可以在远程Maven仓库中看到正式发布的1.0版本。</p>

<p>这可是自动化的 ，正式的 版本发布！</p></blockquote>

<h4>注意点</h4>

<p>svn client的版本号，1.6的版本执行的时候需要手动确认版本号， 1.7不需要。</p>

<p>maven项目中的依赖其他的jar包，不能是SNAPSHOT版本的。(同时开发的项目可以用module的形式引入)。</p>

<p>从trunk打branches、tags以及从tags打branches、或者从branches打tags以上命令都支持，一般执行release:perform都需要先执行release:prepare.</p>

<p>修改trunk的版本号或者branches的版本号，可以用release:update-versions命令。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wiremock在maven环境下的应用]]></title>
    <link href="http://yangtao309.github.io/blog/2013/07/05/wiremock-example-for-maven/"/>
    <updated>2013-07-05T22:18:00+08:00</updated>
    <id>http://yangtao309.github.io/blog/2013/07/05/wiremock-example-for-maven</id>
    <content type="html"><![CDATA[<h4>wiremock是什么</h4>

<p><em>wiremock</em>是一个用来做Web服务存根和<em>mock</em>的灵活工具库。与常用的<em>mock</em>工具不一样的是，<em>wiremock</em>通过创建一个真实的http服务，让你的代码在测试上可以连接到真正的Web服务</p>

<p>它支持HTTP响应存根,请求验证,代理/拦截,记录/回放的存根和故障注入,可以从内部使用单元测试或部署到测试环境。</p>

<p>尽管是用java编写的，有一套<em>Json api</em>可以与其他语言完美结合使用。</p>

<p>官方地址:<a href="http://wiremock.org/">http://wiremock.org/</a></p>

<h4>解决了什么问题</h4>

<p>在大前端的推动下，不少web系统采用前端和后端分离架构，前端只需要调用<em>restful</em>服务API即可拿到交互数据。在约定好api接口后，web开发团和API服务团队可以并行开发。
可以让各司其职，各自处理自己擅长的部分，让事情做起来更高效。</p>

<h4>maven support</h4>

<h6>1.    需要将前端代码独立成一个web maven项目。</h6>

<p>需要按wiremock的方式放置文件目录:需要保包含<em>__files</em>和<em>mapping</em>目录。当<em>wiremock</em>以文件的方式进行独立运行时，
需要将文件放置在<em>__files</em>目录下用来作为文档根目录。而<em>mapping</em>目录作为映射请求url的json数据存储目录以及定义url和json数据的映射关系。</p>

<p>目录组织方式如下图</p>

<p><img src="http://yangtao309.github.io/images/front_end_dir.jpg" width="350" height="350" title="image" alt="images"></p>

<p>pom.xml的配置片段</p>

<p><img src="http://yangtao309.github.io/images/front_pom.jpg" width="350" height="350" title="image" alt="images"></p>

<h6>2.    将整个应用程序集成的一个web maven项目。</h6>

<p><img src="http://yangtao309.github.io/images/war_integration_pom.jpg" width="350" height="350" title="image" alt="images"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Github上安装octopress博客]]></title>
    <link href="http://yangtao309.github.io/blog/2013/07/02/octopress-in-github-pages/"/>
    <updated>2013-07-02T21:09:00+08:00</updated>
    <id>http://yangtao309.github.io/blog/2013/07/02/octopress-in-github-pages</id>
    <content type="html"><![CDATA[<p>周末闲来无事，学习了一下怎样利用github pages来建立自己的博客，现在比较成熟的博客系统是Octopress，关于其详细的介绍可以参见官方文档。
本文安装是基于window xp 32系统，参考地址:<a href="http://jinlong.github.io/blog/2013/03/15/deploy-github-pages-using-octopress-on-windows/">http://jinlong.github.io/blog/2013/03/15/deploy-github-pages-using-octopress-on-windows/</a></p>

<ol>
<li>已拥有github账号 没有的同学可以去 <a href="https://github.com">https://github.com</a> 上申请。</li>
<li>需要在window机器上安装Git 安装好Git后，安装目录下提供了一个叫Git Bash的cmd工具</li>
<li>安装ruby环境 rvm在window下没法安装，以及替代安装工具Pik的安装也需要依赖rubygems工具。所以最后选择RubyInstaller安装程序，一键安装。 安装好后，需要将其配置在环境变量->系统变量的Path中</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>*.;C:\Ruby<span class="m">193</span>\bin;C:\Program Files\Git\bin;C:\Program Files\Git\cmd
</span></code></pre></td></tr></table></div></figure>


<p>安装DevKit，ruby的一个开发工具集
更新配置 中文 utf-8 编码的支持，在win7环境变量中配置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>LANG<span class="o">=</span>zh_CN.UTF<span class="m">-8</span>
</span><span class='line'>LC_ALL<span class="o">=</span>zh_CN.UTF<span class="m">-8</span>
</span></code></pre></td></tr></table></div></figure>


<p>变更 gem 的更新源，变更如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>gem sources --remove http:<span class="n">//rubygems.org/</span>
</span><span class='line'>gem sources -a http:<span class="n">//ruby.taobao.org/</span>
</span><span class='line'>gem sources -l
</span></code></pre></td></tr></table></div></figure>


<p>进入Git Bash cmd，执行如下命令安装bundler</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>gem install bundler
</span></code></pre></td></tr></table></div></figure>


<p>安装Octopress 下载Octopress源代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>git clone git:<span class="n">//github.com/imathis/octopress.git</span> octopress
</span><span class='line'><span class="k">cd</span> octopress # <span class="k">If</span> you use RVM<span class="p">,</span> You&#39;ll be asked <span class="k">if</span> you trust the .rvmrc file (say yes).
</span><span class='line'>ruby --version # Should report Ruby <span class="m">1</span>.<span class="m">9</span>.<span class="m">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>安装依赖模块</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'><span class="k">cd</span> octopress
</span><span class='line'>vi GemFile
</span><span class='line'>将行 ： source <span class="s2">&quot;http://rubygems.org/&quot;</span>
</span><span class='line'>改为 ： source <span class="s2">&quot;http://ruby.taobao.org/&quot;</span>
</span><span class='line'>$ bundle install
</span></code></pre></td></tr></table></div></figure>


<p>安装默认主题</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake install
</span></code></pre></td></tr></table></div></figure>


<p>发布到github上</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake setup_github_pages # 会提示要输入对应的github地址，例如 https:<span class="n">//github.com/yangtao309/yangtao309.github.com.git</span>
</span></code></pre></td></tr></table></div></figure>


<p>生成博客系统以及预览</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake generate # 生成文件
</span><span class='line'>rake preview  # 预览系统，默认访问地址 http:<span class="n">//127.0.0.1:4000</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后就是提交代码到github</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>rake deploy # 会提示输入github的账号和密码信息
</span></code></pre></td></tr></table></div></figure>


<p>简单的octopress搭建就算完成了。后面就是些blog内容和安装分享插件bshare和微博右侧栏、以及新的主题替换啦。</p>
]]></content>
  </entry>
  
</feed>
